<!doctype html><html lang=en dir=ltr><head><meta property="og:title" content="OkHttp 使用及源码分析 "><meta property="og:description" content="https://juejin.cn/post/6881436122950402056
请求流程 #  同步请求 #  MainActivity.kt
val user = &#34;guanpj&#34;  val client = OkHttpClient.Builder()  .connectTimeout(15, TimeUnit.SECONDS)  .writeTimeout(30, TimeUnit.SECONDS)  .readTimeout(30, TimeUnit.SECONDS)  .proxy(Proxy.NO_PROXY)  .addInterceptor(HttpLoggingInterceptor { message ->  if (BuildConfig.DEBUG) {  Log.i(&#34;OkHttp&#34;, message)  }  })  .build()  val request: Request = Request.Builder()  .url(&#34;https://api.github.com/users/$user/repos&#34;)  .build()  val response = client.newCall(request).execute()  println(&#34;Response status code: ${response.code}&#34;) OkHttpClient.kt
/** Prepares the [request] to be executed at some point in the future."><meta property="og:type" content="article"><meta property="og:url" content="https://guanpj.github.io/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><meta property="article:section" content="Knowledge"><meta property="og:site_name" content="guanpj's blog"><title>OkHttp 使用及源码分析 | guanpj's blog</title><link rel=manifest href=/amethyst/manifest.json><link rel=icon href=/amethyst/favicon.png type=image/x-icon><link rel=stylesheet href=/amethyst/book.min.c27ff4755c78daab11627953d5a6dd7e2698690e086398032995aae74d6397b6.css integrity="sha256-wn/0dVx42qsRYnlT1abdfiaYaQ4IY5gDKZWq501jl7Y=" crossorigin=anonymous><meta charset=utf-8><meta name=description content="https://juejin.cn/post/6881436122950402056
请求流程 #  同步请求 #  MainActivity.kt
val user = &#34;guanpj&#34;  val client = OkHttpClient.Builder()  .connectTimeout(15, TimeUnit.SECONDS)  .writeTimeout(30, TimeUnit.SECONDS)  .readTimeout(30, TimeUnit.SECONDS)  .proxy(Proxy.NO_PROXY)  .addInterceptor(HttpLoggingInterceptor { message ->  if (BuildConfig.DEBUG) {  Log.i(&#34;OkHttp&#34;, message)  }  })  .build()  val request: Request = Request.Builder()  .url(&#34;https://api.github.com/users/$user/repos&#34;)  .build()  val response = client.newCall(request).execute()  println(&#34;Response status code: ${response.code}&#34;) OkHttpClient.kt
/** Prepares the [request] to be executed at some point in the future."><title>OkHttp 使用及源码分析</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://guanpj.github.io/amethyst//favicon.png><link href=https://guanpj.github.io/amethyst/styles.e08ceb33360cec132feb69cfb982e2a4.min.css rel=stylesheet><link href=https://guanpj.github.io/amethyst/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://guanpj.github.io/amethyst/quartz/js/darkmode.1bc498b60ed24d8858f74f99e480db82.min.js></script>
<script src=https://guanpj.github.io/amethyst/quartz/js/util.c69e233dc1cc331a30b0f670e657b425.min.js></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://guanpj.github.io/amethyst/quartz/js/popover.f03552ccb84d99ca615d1cfb9abde59e.min.js></script>
<script defer src=https://guanpj.github.io/amethyst/quartz/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://guanpj.github.io/amethyst/quartz/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://guanpj.github.io/amethyst/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://guanpj.github.io/amethyst/",fetchData=Promise.all([fetch("https://guanpj.github.io/amethyst/indices/linkIndex.f13ba8f7c67305f3500d259bdfb72f53.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://guanpj.github.io/amethyst/indices/contentIndex.1d36e1d8fc5979d61a65084cf1563896.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://guanpj.github.io/amethyst",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://guanpj.github.io/amethyst",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://guanpj.github.io/amethyst/quartz/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><header class=book-header><label for=menu-control><img src=/amethyst/svg/menu.svg class=book-icon alt=Menu></label><h1 id=page-title><a href=https://guanpj.github.io/amethyst/>guanpj's blog</a></h1><div class=spacer></div><div id=search-icon class=quartz-search><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control><main class=flex><aside class=book-menu><div class=book-menu-content><nav><div class=menu-search><div id=search-icon class=quartz-search><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div></div><ul><li><span class=book-menu-title>Atlas</span><ul><li><a href=/amethyst/Atlas/About-Atlas/>About Atlas</a></li><li><a href=/amethyst/Atlas/Index-for-Atlases/>Index for Atlases</a></li></ul></li><li><span class=book-menu-title>Dashborads</span><ul><li><a href=/amethyst/Dashborad/Buttons/>Buttons</a></li><li><a href=/amethyst/Dashborad/ControlPanel/>Control Panel</a></li></ul></li><li><span class=book-menu-title>Excalidraws</span><ul><li><a href=/amethyst/Excalidraw/MyDraw/>My Draw</a></li></ul></li><li><span class=book-menu-title>Extras</span><ul><li><a href=/amethyst/Extras/Linter/>Linter</a></li><li><a href=/amethyst/Extras/Index-for-Extras/>Index for Extras</a></li></ul></li><li><span class=book-menu-title>Knowledges</span><ul><li><a href=/amethyst/Knowledge/Kotlin/%E5%A7%94%E6%89%98/>委托</a></li><li><a href=/amethyst/Knowledge/Kotlin/%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/>扩展函数</a></li><li><a href=/amethyst/Knowledge/Python/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2/>文件读取、文本替换</a></li><li><a href=/amethyst/Knowledge/Python/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8/>类的定义、使用</a></li><li><a href=/amethyst/Knowledge/Python/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D/>遍历文件、重命名</a></li><li><a href=/amethyst/Knowledge/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%95%E7%94%A8/>引用</a></li><li><a href=/amethyst/Knowledge/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8C%87%E9%92%88/>指针</a></li><li><a href=/amethyst/Knowledge/Android/Android-%E5%9F%BA%E7%A1%80/ADB-%E5%91%BD%E4%BB%A4/>ADB 命令</a></li><li><a href=/amethyst/Knowledge/Android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8F%92%E4%BB%B6%E5%8C%96/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/>ADB 命令</a></li><li><a href=/amethyst/Knowledge/Android/Android-%E5%9F%BA%E7%A1%80/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96/>Android 对容器类的优化</a></li><li><a href=/amethyst/Knowledge/Java/%E5%B9%B6%E5%8F%91/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/>CAS 和 AQS 原理</a></li><li><a href=/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>EventBus 使用及源码解析</a></li><li><a href=/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/>Glide 加载流程和缓存原理分析</a></li><li><a href=/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/>Glide 基本使用</a></li><li><a href=/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/>Glide 高级用法</a></li><li><a href=/amethyst/Knowledge/Java/%E5%9F%BA%E7%A1%80/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>HashMap 源码解析</a></li><li><a href=/amethyst/Knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/HTTP-%E5%9F%BA%E7%A1%80/>HTTP 基础</a></li><li><a href=/amethyst/Knowledge/Java/%E5%B9%B6%E5%8F%91/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/>Java 内存模型</a></li><li><a href=/amethyst/Knowledge/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>JVM 中的对象和垃圾回收</a></li><li><a href=/amethyst/Knowledge/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/>JVM 内存区域</a></li><li><a href=/amethyst/Knowledge/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/>JVM 字节码指令简介</a></li><li><a href=/amethyst/Knowledge/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/>JVM 字节码结构分析</a></li><li><a href=/amethyst/Knowledge/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/>JVM 类加载机制</a></li><li><a href=/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>LeakCanary 使用及源码解析</a></li><li><a href=/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/ class=active>OkHttp 使用及源码分析</a></li><li><a href=/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>Retrofit 使用及源码分析</a></li><li><a href=/amethyst/Knowledge/Android/%E5%BC%80%E6%BA%90%E5%BA%93/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>RxJava 使用及源码分析</a></li><li><a href=/amethyst/Knowledge/Android/Framework/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87/>一、Binder 机制分析——概念篇</a></li><li><a href=/amethyst/Knowledge/Android/Framework/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/>七、View 事件机制分析</a></li><li><a href=/amethyst/Knowledge/Android/Framework/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/>三、Handler 原理分析</a></li><li><a href=/amethyst/Knowledge/Android/Framework/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87/>二、Binder 机制分析——应用篇</a></li><li><a href=/amethyst/Knowledge/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/>二叉树遍历</a></li><li><a href=/amethyst/Knowledge/Android/Framework/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>五、App 启动流程分析</a></li><li><a href=/amethyst/Knowledge/Android/Framework/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>六、View 绘制流程分析</a></li><li><a href=/amethyst/Knowledge/Android/Framework/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>四、系统启动流程分析</a></li><li><a href=/amethyst/Knowledge/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8%E7%B1%BB/>容器类</a></li><li><a href=/amethyst/Knowledge/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/>并发容器</a></li><li><a href=/amethyst/Knowledge/Java/%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B/>泛型</a></li><li><a href=/amethyst/Knowledge/Java/%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/>注解和反射</a></li><li><a href=/amethyst/Knowledge/Java/%E5%B9%B6%E5%8F%91/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/>等待-通知机制</a></li><li><a href=/amethyst/Knowledge/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/>线程协作</a></li><li><a href=/amethyst/Knowledge/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/>线程基础</a></li><li><a href=/amethyst/Knowledge/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue/>线程池和 BlockingQueue</a></li><li><a href=/amethyst/Knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/>编码、加密、Hash、序列化和字符集</a></li><li><a href=/amethyst/Knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84TCPIP-%E5%92%8C-HTTPS/>计算机网络体系结构、TCP&IP 和 HTTPS</a></li><li><a href=/amethyst/Knowledge/Java/%E5%B9%B6%E5%8F%91/%E9%94%81/>锁</a></li></ul></li><li><span class=book-menu-title>Notes</span><ul><li><a href=/amethyst/Notes/2023-03-15/>2023 03 15</a></li><li><a href=/amethyst/Notes/2023-03-18/>2023 03 18</a></li><li><a href=/amethyst/Notes/2023-03-19/>2023 03 19</a></li><li><a href=/amethyst/Notes/2023-03-20/>2023 03 20</a></li><li><a href=/amethyst/Notes/2023-03-22/>Troubleshooting and FAQ</a></li></ul></li></ul><ul><li><a href=https://github.com/64bitpandas/amethyst target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class="book-page container"><article class=markdown><h1 class=title>OkHttp 使用及源码分析</h1><p><a href=https://juejin.cn/post/6881436122950402056 rel=noopener>https://juejin.cn/post/6881436122950402056</a></p><h1 id=请求流程>请求流程
<a class=anchor href=#%e8%af%b7%e6%b1%82%e6%b5%81%e7%a8%8b>#</a></h1><h2 id=strong同步请求strong><strong>同步请求</strong>
<a class=anchor href=#strong%e5%90%8c%e6%ad%a5%e8%af%b7%e6%b1%82strong>#</a></h2><p><em>MainActivity.kt</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> user = <span style=color:#e6db74>&#34;guanpj&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> client = OkHttpClient.Builder()
</span></span><span style=display:flex><span>    .connectTimeout(<span style=color:#ae81ff>15</span>, TimeUnit.SECONDS)
</span></span><span style=display:flex><span>    .writeTimeout(<span style=color:#ae81ff>30</span>, TimeUnit.SECONDS)
</span></span><span style=display:flex><span>    .readTimeout(<span style=color:#ae81ff>30</span>, TimeUnit.SECONDS)
</span></span><span style=display:flex><span>    .proxy(Proxy.NO_PROXY)
</span></span><span style=display:flex><span>    .addInterceptor(HttpLoggingInterceptor { message <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (BuildConfig.DEBUG) {
</span></span><span style=display:flex><span>            Log.i(<span style=color:#e6db74>&#34;OkHttp&#34;</span>, message)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .build()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> request: Request = Request.Builder()
</span></span><span style=display:flex><span>    .url(<span style=color:#e6db74>&#34;https://api.github.com/users/</span><span style=color:#e6db74>$user</span><span style=color:#e6db74>/repos&#34;</span>)
</span></span><span style=display:flex><span>    .build()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> response = client.newCall(request).execute()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(<span style=color:#e6db74>&#34;Response status code: </span><span style=color:#e6db74>${response.code}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p><em>OkHttpClient.kt</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>/** Prepares the [request] to be executed at some point in the future. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>newCall</span>(request: Request): Call =
</span></span><span style=display:flex><span>         RealCall(<span style=color:#66d9ef>this</span>, request, forWebSocket = <span style=color:#66d9ef>false</span>)
</span></span></code></pre></div><p><em>RealCall.execute</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>execute</span>(): Response {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//保证每个 call 只能被执行一次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  check(executed.compareAndSet(<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>)) { <span style=color:#e6db74>&#34;Already Executed&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  timeout.enter()
</span></span><span style=display:flex><span>  callStart()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    client.dispatcher.executed(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> getResponseWithInterceptorChain()
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>    client.dispatcher.finished(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>Dispatcher.executed</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Synchronized</span> <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>executed</span>(call: RealCall) {
</span></span><span style=display:flex><span>  runningSyncCalls.add(call)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，在 extcuted 方法中并没有具体执行请求的方法，仅仅是把当前对象存入 runningSyncCalls 集合中。同步请求的核心部分在接下来的 getResponseWithInterceptorChain 中，此方法直接返回了请求结果 Response，事实上这个方法调用栈非常复杂，这里先按下不表。最后在 finially 代码块中调用了 <code>client.dispatcher.finished(this)</code>，也是传入了 this 对象，我们有理由猜测这一步就是将它从 runningSyncCalls 集合中移除，这里同样等到异步请求流程一并分析。</p><h2 id=strong异步请求strong><strong>异步请求</strong>
<a class=anchor href=#strong%e5%bc%82%e6%ad%a5%e8%af%b7%e6%b1%82strong>#</a></h2><p><em>MainActivity.kt</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> user = <span style=color:#e6db74>&#34;guanpj&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> client = OkHttpClient.Builder()
</span></span><span style=display:flex><span>    .build()
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> request: Request = Request.Builder()
</span></span><span style=display:flex><span>    .url(<span style=color:#e6db74>&#34;https://api.github.com/users/</span><span style=color:#e6db74>$user</span><span style=color:#e6db74>/repos&#34;</span>)
</span></span><span style=display:flex><span>    .build()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>client.newCall(request)
</span></span><span style=display:flex><span>    .enqueue(<span style=color:#66d9ef>object</span> <span style=color:#960050;background-color:#1e0010>: </span><span style=color:#a6e22e>Callback</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onFailure</span>(call: Call, e: IOException) {
</span></span><span style=display:flex><span>            e.printStackTrace()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onResponse</span>(call: Call, response: Response) {
</span></span><span style=display:flex><span>            println(<span style=color:#e6db74>&#34;Response status code: </span><span style=color:#e6db74>${response.code}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span></code></pre></div><p><em>RealCall.enqueue</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>enqueue</span>(responseCallback: Callback) {
</span></span><span style=display:flex><span>  check(executed.compareAndSet(<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>)) { <span style=color:#e6db74>&#34;Already Executed&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  callStart()
</span></span><span style=display:flex><span>  <span style=color:#75715e>//包装成 AsyncCall，放入待执行的异步请求请求列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  client.dispatcher.enqueue(AsyncCall(responseCallback))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>Dispatcher.enqueue</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>enqueue</span>(call: AsyncCall) {
</span></span><span style=display:flex><span>  synchronized(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//首先将 call 放入 readyAsyncCalls 集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    readyAsyncCalls.add(call)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the same host.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (!call.call.forWebSocket) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> existingCall = findExistingCallWithHost(call.host)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (existingCall <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) call.reuseCallsPerHostFrom(existingCall)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//然后调用此方法执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  promoteAndExecute()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>readyAsyncCalls 意思温为“准备好的异步请求”，而 promoteAndExecute 方法单从命名来看就是提升和执行，具体分析如下：</p><p><em>Dispatcher.promoteAndExecute</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>promoteAndExecute</span>(): Boolean {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.assertThreadDoesntHoldLock()
</span></span><span style=display:flex><span>  <span style=color:#75715e>//新建一个列表存放可执行的请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> isRunning: Boolean
</span></span><span style=display:flex><span>  synchronized(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> i = readyAsyncCalls.iterator()
</span></span><span style=display:flex><span>    <span style=color:#75715e>//遍历准备好的异步请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (i.hasNext()) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> asyncCall = i.next()
</span></span><span style=display:flex><span>      <span style=color:#75715e>//总请求数不能超过 64 个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (runningAsyncCalls.size <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>this</span>.maxRequests) <span style=color:#66d9ef>break</span> <span style=color:#75715e>// Max capacity.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>//每个主机请求数量不能超过 5 个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (asyncCall.callsPerHost.<span style=color:#66d9ef>get</span>() <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>this</span>.maxRequestsPerHost) <span style=color:#66d9ef>continue</span> <span style=color:#75715e>// Host max capacity.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>//从 readyAsyncCalls 集合中移除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      i.remove()
</span></span><span style=display:flex><span>      <span style=color:#75715e>//安全自增
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      asyncCall.callsPerHost.incrementAndGet()
</span></span><span style=display:flex><span>      <span style=color:#75715e>//加入到 executableCalls 集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      executableCalls.add(asyncCall)
</span></span><span style=display:flex><span>      <span style=color:#75715e>//加入到 runningAsyncCalls 集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      runningAsyncCalls.add(asyncCall)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//获取正在执行中的请求（同步和异步）总数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    isRunning = runningCallsCount() &gt; <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//遍历可执行请求的集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span> until executableCalls.size) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> asyncCall = executableCalls[i]
</span></span><span style=display:flex><span>    <span style=color:#75715e>//调用它们的 executeOn 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    asyncCall.executeOn(executorService)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//返回正在执行中的请求（同步和异步）总数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> isRunning
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Synchronized</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>runningCallsCount</span>(): Int 
</span></span><span style=display:flex><span>        = runningAsyncCalls.size + runningSyncCalls.size
</span></span></code></pre></div><p>可以看到，该方法可拆分为三个步骤：</p><ol><li>首先，一个请求从上一步被放入 readyAsyncCalls 集合中，在这里将遍历该集合并在条件允许的情况下将集合中的请求移除并分别加入到 runningAsyncCalls 和 executableCalls 集合；</li><li>接着遍历 executableCalls 集合并调用每个 AysncCall 的 executeOn 方法，并传入 executorService 对像用于执行这个 Call。AsyncCall 是 RealCall 中的一个内部类；</li><li>最后返回正在执行中的同步和异步请求的总数。</li></ol><p>这里重点看第二点：</p><p><em>RealCall.AsyncCall</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AsyncCall</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> responseCallback: Callback
</span></span><span style=display:flex><span>) : Runnable {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Volatile</span> <span style=color:#66d9ef>var</span> callsPerHost = AtomicInteger(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>reuseCallsPerHostFrom</span>(other: AsyncCall) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.callsPerHost = other.callsPerHost
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> host: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>get</span>() = originalRequest.url.host
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> request: Request
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>get</span>() = originalRequest
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> call: RealCall
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>get</span>() = <span style=color:#66d9ef>this</span><span style=color:#a6e22e>@RealCall</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * Attempt to enqueue this async call on [executorService]. This will attempt to clean up
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * if the executor has been shut down by reporting the call as failed.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>executeOn</span>(executorService: ExecutorService) {
</span></span><span style=display:flex><span>    client.dispatcher.assertThreadDoesntHoldLock()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> success = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//调用 executorService 执行自己
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      executorService.execute(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>      success = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (e: RejectedExecutionException) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> ioException = InterruptedIOException(<span style=color:#e6db74>&#34;executor rejected&#34;</span>)
</span></span><span style=display:flex><span>      ioException.initCause(e)
</span></span><span style=display:flex><span>      noMoreExchanges(ioException)
</span></span><span style=display:flex><span>      responseCallback.onFailure(<span style=color:#66d9ef>this</span><span style=color:#a6e22e>@RealCall</span>, ioException)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (!success) {
</span></span><span style=display:flex><span>        client.dispatcher.finished(<span style=color:#66d9ef>this</span>) <span style=color:#75715e>// This call is no longer running!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>//被 executorService.execute 时调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    threadName(<span style=color:#e6db74>&#34;OkHttp </span><span style=color:#e6db74>${redactedUrl()}</span><span style=color:#e6db74>&#34;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> signalledCallback = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>      timeout.enter()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//1、在 executorService 中异步执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>val</span> response = getResponseWithInterceptorChain()
</span></span><span style=display:flex><span>        signalledCallback = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//2、回调结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        responseCallback.onResponse(<span style=color:#66d9ef>this</span><span style=color:#a6e22e>@RealCall</span>, response)
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (e: IOException) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (signalledCallback) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Do not signal the callback twice!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          Platform.<span style=color:#66d9ef>get</span>().log(<span style=color:#e6db74>&#34;Callback failure for </span><span style=color:#e6db74>${toLoggableString()}</span><span style=color:#e6db74>&#34;</span>, Platform.INFO, e)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>//回调结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          responseCallback.onFailure(<span style=color:#66d9ef>this</span><span style=color:#a6e22e>@RealCall</span>, e)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (t: Throwable) {
</span></span><span style=display:flex><span>        cancel()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!signalledCallback) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>val</span> canceledException = IOException(<span style=color:#e6db74>&#34;canceled due to </span><span style=color:#e6db74>$t</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>          canceledException.addSuppressed(t)
</span></span><span style=display:flex><span>          <span style=color:#75715e>//回调结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          responseCallback.onFailure(<span style=color:#66d9ef>this</span><span style=color:#a6e22e>@RealCall</span>, canceledException)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> t
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//3、后续操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        client.dispatcher.finished(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为是异步请求，所以请求操作必然是在异步线程中执行的，可以看到，在 run 方法中，异步请求正常情况下分为三个步骤：</p><ol><li>调用 getResponseWithInterceptorChain 方法获取 Resonse 结果，这点和同步请求一样。</li><li>将 Response 对象通过 responseCallback 进行回调。</li><li>在 finally 中调用 <code>client.dispatcher.finished(this)</code> 方法。</li></ol><p>第一步还是留到后面，第二步无须多解释，来看第三步，在同步请求流程的足后也同样执行了这个步骤。</p><p><em>Dispatcher.finish</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>finished</span>(call: AsyncCall) {
</span></span><span style=display:flex><span>  call.callsPerHost.decrementAndGet()
</span></span><span style=display:flex><span>  finished(runningAsyncCalls, call)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>finished</span>(call: RealCall) {
</span></span><span style=display:flex><span>  finished(runningSyncCalls, call)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span>&gt; <span style=color:#a6e22e>finished</span>(calls: Deque&lt;T&gt;, call: T) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> idleCallback: Runnable?
</span></span><span style=display:flex><span>  synchronized(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (!calls.remove(call)) <span style=color:#66d9ef>throw</span> AssertionError(<span style=color:#e6db74>&#34;Call wasn&#39;t in-flight!&#34;</span>)
</span></span><span style=display:flex><span>    idleCallback = <span style=color:#66d9ef>this</span>.idleCallback
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> isRunning = promoteAndExecute()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!is</span>Running <span style=color:#f92672>&amp;&amp;</span> idleCallback <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    idleCallback.run()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不管同步还是异步的 Call，最后都会走到最后一个方法，果然这里分别移除了 runningAsyncCalls 和 runningSyncCalls 集合中的 Call 对象。除此之外，这里再次调用了 promoteAndExecute 方法，前面提到过，这里返回的是正在执行中的同步和异步请求个数。当所有请求都执行完成后，会调用 idleCallback.run 方法进行回调。</p><h2 id=getresponsewithinterceptorchain>getResponseWithInterceptorChain
<a class=anchor href=#getresponsewithinterceptorchain>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getResponseWithInterceptorChain</span>(): Response {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Build a full stack of interceptors.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> interceptors = mutableListOf&lt;Interceptor&gt;()
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> client.interceptors
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> RetryAndFollowUpInterceptor(client)
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> BridgeInterceptor(client.cookieJar)
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> CacheInterceptor(client.cache)
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> ConnectInterceptor
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (!forWebSocket) {
</span></span><span style=display:flex><span>    interceptors <span style=color:#f92672>+=</span> client.networkInterceptors
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> CallServerInterceptor(forWebSocket)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> chain = RealInterceptorChain(
</span></span><span style=display:flex><span>      call = <span style=color:#66d9ef>this</span>,
</span></span><span style=display:flex><span>      interceptors = interceptors,
</span></span><span style=display:flex><span>      index = <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>      exchange = <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>      request = originalRequest,
</span></span><span style=display:flex><span>      connectTimeoutMillis = client.connectTimeoutMillis,
</span></span><span style=display:flex><span>      readTimeoutMillis = client.readTimeoutMillis,
</span></span><span style=display:flex><span>      writeTimeoutMillis = client.writeTimeoutMillis
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> calledNoMoreExchanges = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> response = chain.proceed(originalRequest)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isCanceled()) {
</span></span><span style=display:flex><span>      response.closeQuietly()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> IOException(<span style=color:#e6db74>&#34;Canceled&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> response
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (e: IOException) {
</span></span><span style=display:flex><span>    calledNoMoreExchanges = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> noMoreExchanges(e) <span style=color:#66d9ef>as</span> Throwable
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (!calledNoMoreExchanges) {
</span></span><span style=display:flex><span>      noMoreExchanges(<span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>首先将以下拦截器依次加入到 List 中：</p><ol><li>OkHttpClient 设置的拦截器 interceptors()</li><li>重试、重定向拦截器 RetryAndFollowUpInterceptor</li><li>把用户请求转换为服务器请求、把服务器返响应转换为用户响应的 BridgeInterceptor</li><li>读取缓存直接返回、将响应写入到缓存中的 CacheInterceptor</li><li>与服务器建立连接的 ConnectInterceptor</li><li>OkHttpClient 设置的网络拦截器 networkInterceptors()</li><li>真正执行网络请求的 CallServerInterceptor</li></ol><p>将所有的拦截器保存在 interceptors 集合中后，创建一个拦截器责任链 RealInterceptorChain，并调用其 proceed 开始处理网络请求。那么责任链模式是如何工作的呢？</p><p>首先查看 RealInterceptorChain 的源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RealInterceptorChain</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> call: RealCall,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> interceptors: List&lt;Interceptor&gt;,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> index: Int,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> exchange: Exchange?,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> request: Request,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> connectTimeoutMillis: Int,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> readTimeoutMillis: Int,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> writeTimeoutMillis: Int
</span></span><span style=display:flex><span>) : Interceptor.Chain {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> calls: Int = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>copy</span>(
</span></span><span style=display:flex><span>    index: Int = <span style=color:#66d9ef>this</span>.index,
</span></span><span style=display:flex><span>    exchange: Exchange? = <span style=color:#66d9ef>this</span>.exchange,
</span></span><span style=display:flex><span>    request: Request = <span style=color:#66d9ef>this</span>.request,
</span></span><span style=display:flex><span>    connectTimeoutMillis: Int = <span style=color:#66d9ef>this</span>.connectTimeoutMillis,
</span></span><span style=display:flex><span>    readTimeoutMillis: Int = <span style=color:#66d9ef>this</span>.readTimeoutMillis,
</span></span><span style=display:flex><span>    writeTimeoutMillis: Int = <span style=color:#66d9ef>this</span>.writeTimeoutMillis
</span></span><span style=display:flex><span>  ) = RealInterceptorChain(call, interceptors, index, exchange, request, connectTimeoutMillis,
</span></span><span style=display:flex><span>      readTimeoutMillis, writeTimeoutMillis)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Throws</span>(IOException<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>proceed</span>(request: Request): Response {
</span></span><span style=display:flex><span>    check(index &lt; interceptors.size)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    calls<span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Call the next interceptor in the chain.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>val</span> next = copy(index = index + <span style=color:#ae81ff>1</span>, request = request)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> interceptor = interceptors[index]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Suppress</span>(<span style=color:#e6db74>&#34;USELESS_ELVIS&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> response = interceptor.intercept(next) <span style=color:#f92672>?:</span> <span style=color:#66d9ef>throw</span> NullPointerException(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;interceptor </span><span style=color:#e6db74>$interceptor</span><span style=color:#e6db74> returned null&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> response
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在不考虑 OkHttpClient.interceptor() 的情况下，首次执行 getResponseWithInterceptorChain 方法时上面这两段代码的解释如下：</p><ol><li>在 getResponseWithInterceptorChain 创建了一个 index 为 0 的 RealInterceptorChain，接着调用了其 proceed 方法；</li><li>在 RealInterceptorChain.proceed 方法中，将 index+1 并且和其它成员变量一起 copy 出一个新的 RealInterceptorChain 对象 next；</li><li>然后对当前 index 的拦截器（即 RetryAndFollowUpInterceptor）执行 interceptor.intercept(next)。在 RetryAndFollowUpInterceptor 方法中执行了 next.proceed 方法，而这里的 next 同样是 RealInterceptorChain 实例，所以回到了 RealInterceptorChain.proceed 方法中；</li><li>此时 index=1，同理链条可以一直执行下去直到 index 等于 n-1；</li><li>遇到最后一个拦截器 CallServerInterceptor，链不能继续下去了，CallServerInterceptor.intercept 方法中也不会再 proceed 了；</li><li>CallServerInterceptor 建立连接后开始递归返回，Response 的返回与 Request 相反，会从最后一个开始依次往前经过这些 Intercetor。</li></ol><p>下图为 OkHttp 工作的大致流程，参考自
<a href=https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html rel=noopener>拆轮子系列：拆 OkHttp</a></p><p><img src=https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035335.png width=auto alt></p><p>同步请求和异步请求流程时序图如下：</p><p><img src=https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035341.png width=auto alt></p><h1 id=okhttpclient>OkHttpClient
<a class=anchor href=#okhttpclient>#</a></h1><p>OkHttpClient 相当于配置中心，所有的请求都会共享这些配置（例如出错是否重试、共享的连接池）。 OkHttpClient 中的配置主要有:</p><ul><li><code>Dispatcher dispatcher</code> : 调度器，用于调度后台发起的网络请求， 有后台总请求数和单主机总请求数的控制。</li><li><code>List&lt;Protocol> protocols</code> : 支持的应用层协议，即 HTTP/1.1、 HTTP/2 等。</li><li><code>List&lt;ConnectionSpec> connectionSpecs</code> : 应用层支持的 Socket 设置，即使用明文传输（用于 HTTP）还是某个版本的 TLS（用于 HTTPS）。</li><li><code>List&lt;Interceptor> interceptors</code> : 大多数时候使用的 Interceptor 都应该配置到这里。</li><li><code>List&lt;Interceptor> networkInterceptors</code> : 直接和网络请求交互的 Interceptor 配置到这里，例如如果要查看返回的 301 报文或者未解压的 Response Body，需要在这里看。</li><li>CookieJar cookieJar : 管理 Cookie 的控制器。OkHttp 提供了 Cookie 存取的判断支持（即什么时候需要存 Cookie，什么时候需要读取 Cookie，但没有给出具体的存取实现。如果需要存取 Cookie，需要自己写实现，例如用 Map 存在内存里，或者用别的方式存在本地存储或者数据库。</li><li>Cache cache : Cache 存储的配置。默认是没有，如果需要用，得自己配置出 Cache 存储的文件位置以及存储空间上限。</li><li>HostnameVerifier hostnameVerifier : 用于验证 HTTPS 握手过程中下载到的证书所属者是否和自己要访问的主机名一致。</li><li>CertificatePinner certificatePinner : 用于设置 HTTPS 握手 过程中针对某个 Host 额外的的 Certificate Public Key Pinner，即把网站证书链中的每一个证书公钥直接拿来提前配置进 OkHttpClient 里去，作为正常的证书验证机制之外的一次额外验证。</li><li>Authenticator authenticator : 用于自动重新认证。配置之后，在请求收到 401 状态码的响应时，会直接调用 authenticator ，手动加入 Authorization header 之后自动重新发起请求。</li><li>boolean followRedirects : 遇到重定向的要求是，是否自动 follow。</li><li>boolean followSslRedirects : 在重定向时，如果原先请求的是 http 而重定向的目标是 https，或者原先请求的是 https 而重定向的目标是 http，是否依然自动 follow。注意：不是「是否自动 follow HTTPS URL 重定向的意思，而是是否自动 follow 在 HTTP 和 HTTPS 之间切换的重定向。</li><li>boolean retryOnConnectionFailure : 在请求失败的时候是否自动重试。注意：大多数的请求失败并不属于 OkHttp 所定义的「需要重试」， 这种重试只适用于「同一个域名的多个 IP 切换重试」「Socket 失效重试」 等情况。</li><li>int connectTimeout : 建立连接（TCP 或 TLS）的超时时间。</li><li>int readTimeout : 发起请求到读到响应数据的超时时间。</li><li>int writeTimeout : 发起请求并被目标服务器接受的超时时间。（因为有时候对方服务器可能由于某种原因而不读取你的 Request）</li></ul><h1 id=strongrequest-和-responsestrong><strong>Request 和 Response</strong>
<a class=anchor href=#strongrequest-%e5%92%8c-responsestrong>#</a></h1><p>Request 是发送请求封装类，内部有 url, header , method，body 等常见的参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Request</span> <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>constructor</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;url&#34;</span>) <span style=color:#66d9ef>val</span> url: HttpUrl,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;method&#34;</span>) <span style=color:#66d9ef>val</span> method: String,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;headers&#34;</span>) <span style=color:#66d9ef>val</span> headers: Headers,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;body&#34;</span>) <span style=color:#66d9ef>val</span> body: RequestBody?,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> tags: Map&lt;Class&lt;*&gt;, Any&gt;
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Response 是请求的结果，包含 code、message、header、body:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Response</span> <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>constructor</span>(
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * The wire-level request that initiated this HTTP response. This is not necessarily the same
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * request issued by the application:
</span></span></span><span style=display:flex><span><span style=color:#75715e>   *
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * * It may be transformed by the HTTP client. For example, the client may copy headers like
</span></span></span><span style=display:flex><span><span style=color:#75715e>   *   `Content-Length` from the request body.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * * It may be the request generated in response to an HTTP redirect or authentication
</span></span></span><span style=display:flex><span><span style=color:#75715e>   *   challenge. In this case the request URL may be different than the initial request URL.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;request&#34;</span>) <span style=color:#66d9ef>val</span> request: Request,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/** Returns the HTTP protocol, such as [Protocol.HTTP_1_1] or [Protocol.HTTP_1_0]. */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;protocol&#34;</span>) <span style=color:#66d9ef>val</span> protocol: Protocol,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/** Returns the HTTP status message. */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;message&#34;</span>) <span style=color:#66d9ef>val</span> message: String,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/** Returns the HTTP status code. */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;code&#34;</span>) <span style=color:#66d9ef>val</span> code: Int,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * Returns the TLS handshake of the connection that carried this response, or null if the
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * response was received without TLS.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;handshake&#34;</span>) <span style=color:#66d9ef>val</span> handshake: Handshake?,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/** Returns the HTTP headers. */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;headers&#34;</span>) <span style=color:#66d9ef>val</span> headers: Headers,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * Returns a non-null value if this response was passed to [Callback.onResponse] or returned
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * from [Call.execute]. Response bodies must be [closed][ResponseBody] and may
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * be consumed only once.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   *
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * This always returns null on responses returned from [cacheResponse], [networkResponse],
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * and [priorResponse].
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;body&#34;</span>) <span style=color:#66d9ef>val</span> body: ResponseBody?,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * Returns the raw response received from the network. Will be null if this response didn&#39;t use
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * the network, such as when the response is fully cached. The body of the returned response
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * should not be read.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;networkResponse&#34;</span>) <span style=color:#66d9ef>val</span> networkResponse: Response?,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * Returns the raw response received from the cache. Will be null if this response didn&#39;t use
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * the cache. For conditional get requests the cache response and network response may both be
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * non-null. The body of the returned response should not be read.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;cacheResponse&#34;</span>) <span style=color:#66d9ef>val</span> cacheResponse: Response?,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * Returns the response for the HTTP redirect or authorization challenge that triggered this
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * response, or null if this response wasn&#39;t triggered by an automatic retry. The body of the
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * returned response should not be read because it has already been consumed by the redirecting
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * client.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;priorResponse&#34;</span>) <span style=color:#66d9ef>val</span> priorResponse: Response?,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * Returns a [timestamp][System.currentTimeMillis] taken immediately before OkHttp
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * transmitted the initiating request over the network. If this response is being served from the
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * cache then this is the timestamp of the original request.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;sentRequestAtMillis&#34;</span>) <span style=color:#66d9ef>val</span> sentRequestAtMillis: Long,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * Returns a [timestamp][System.currentTimeMillis] taken immediately after OkHttp
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * received this response&#39;s headers from the network. If this response is being served from the
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * cache then this is the timestamp of the original response.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;receivedResponseAtMillis&#34;</span>) <span style=color:#66d9ef>val</span> receivedResponseAtMillis: Long,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@get</span>:JvmName(<span style=color:#e6db74>&#34;exchange&#34;</span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> exchange: Exchange?
</span></span><span style=display:flex><span>) : Closeable {
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这两个类的定义是完全符合 Http 协议所定义的请求内容和响应内容。</p><h1 id=realcall>RealCall
<a class=anchor href=#realcall>#</a></h1><p>OkHttpClient 的 newCall(Request) 方法会返回一个 RealCall 对象，它是 Call 接口的实现。</p><p>当调用 RealCall.execute() 的时候， RealCall.getResponseWithInterceptorChain() 会被调用，它会发起网络请求并拿到返回的响应，装进一个 Response 对象并作为返回值返回；</p><p>RealCall.enqueue() 被调用的时候大同小异，区别在于 enqueue() 会使用 Dispatcher 的线程池来把请求放在后台线程进行，但实质上使用的也是 getResponseWithInterceptorChain() 方法。</p><p>getResponseWithInterceptorChain() 方法做的事：把所有配置好的 Interceptor 放在一个 List 里，然后作为参数，创建一个 RealInterceptorChain 对象，并调 chain.proceed(request) 来发起请求和获取响应。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getResponseWithInterceptorChain</span>(): Response {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Build a full stack of interceptors.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> interceptors = mutableListOf&lt;Interceptor&gt;()
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> client.interceptors
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> RetryAndFollowUpInterceptor(client)
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> BridgeInterceptor(client.cookieJar)
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> CacheInterceptor(client.cache)
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> ConnectInterceptor
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (!forWebSocket) {
</span></span><span style=display:flex><span>    interceptors <span style=color:#f92672>+=</span> client.networkInterceptors
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  interceptors <span style=color:#f92672>+=</span> CallServerInterceptor(forWebSocket)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> chain = RealInterceptorChain(
</span></span><span style=display:flex><span>      call = <span style=color:#66d9ef>this</span>,
</span></span><span style=display:flex><span>      interceptors = interceptors,
</span></span><span style=display:flex><span>      index = <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>      exchange = <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>      request = originalRequest,
</span></span><span style=display:flex><span>      connectTimeoutMillis = client.connectTimeoutMillis,
</span></span><span style=display:flex><span>      readTimeoutMillis = client.readTimeoutMillis,
</span></span><span style=display:flex><span>      writeTimeoutMillis = client.writeTimeoutMillis
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 RealInterceptorChain 中，多个 Interceptor 会依次调用自己的 intercept() 方法。这个方法会做三件事:</p><ol><li>对请求进行预处理</li><li>预处理之后，重新调用 RealIntercepterChain.proceed() 把请求交给下一个 Interceptor</li><li>在下一个 Interceptor 处理完成并返回之后，拿到 Response 进行后续处理</li></ol><p>结合源码和该示意图，可以得到拦截器具有如下特点：</p><ul><li>拦截器按照添加顺序依次执行</li><li>拦截器的执行从 RealInterceptorChain.proceed() 开始，进入到第一个拦截器的执行逻辑</li><li>每个拦截器在执行之前，会将剩余尚未执行的拦截器组成新的 RealInterceptorChain</li><li>拦截器的逻辑被新的责任链调用 next.proceed() 切分为 start、next.proceed、end 这三个部分依次执行</li><li>next.proceed() 所代表的其实就是剩余所有拦截器的执行逻辑</li><li>所有拦截器最终形成一个层层内嵌的嵌套结构</li></ul><h1 id=interceptor>Interceptor
<a class=anchor href=#interceptor>#</a></h1><p>上面提到过，OkHttp 的所有拦截器会组成链式结构：各个拦截器完成前置工作后调用下一个拦截器的 proceed 方法，再执行后置工作。通过递归调用，每个拦截器完成各自的任务。</p><p><img src=https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035349.png width=auto alt></p><h2 id=clientinterceptors>client.interceptors
<a class=anchor href=#clientinterceptors>#</a></h2><p>首先是开发者使用 addInterceptor(Interceptor) 所设置的，它们会按照开发者的要求，在所有其他 Interceptor 处理之前，进行最早的预处理工作，以及在收到 Response 之后，做最后的善后工作。如果你有统一的 header 要添加，可以在这里设置。</p><h2 id=retryandfollowupinterceptor>RetryAndFollowUpInterceptor
<a class=anchor href=#retryandfollowupinterceptor>#</a></h2><p>它会对连接做一些初始化工作，并且负责在请求失败时的重试，以及重定向的自动后续请求。它的存在，可以让<strong>重试和重定向</strong>对于开发者是无感知的。</p><p>RetryAndFollowUpInterceptor.intercept 代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Throws</span>(IOException<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>intercept</span>(chain: Interceptor.Chain): Response {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> realChain = chain <span style=color:#66d9ef>as</span> RealInterceptorChain
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> request = chain.request
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> call = realChain.call
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> followUpCount = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> priorResponse: Response? = <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> newExchangeFinder = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> recoveredFailures = listOf&lt;IOException&gt;()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>    call.enterNetworkInterceptorExchange(request, newExchangeFinder)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> response: Response
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> closeActiveExchange = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//先判断请求是否已被取消
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (call.isCanceled()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> IOException(<span style=color:#e6db74>&#34;Canceled&#34;</span>)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//执行下一个链的 proceed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        response = realChain.proceed(request)
</span></span><span style=display:flex><span>        newExchangeFinder = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (e: RouteException) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//判断是否能恢复，如果能则继续，否则结束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// The attempt to connect via a route failed. The request will not have been sent.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span style=color:#66d9ef>false</span>)) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>throw</span> e.firstConnectException.withSuppressed(recoveredFailures)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>          recoveredFailures <span style=color:#f92672>+=</span> e.firstConnectException
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        newExchangeFinder = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (e: IOException) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// An attempt to communicate with a server failed. The request may have been sent.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (!recover(e, call, request, requestSendStarted = e <span style=color:#f92672>!is</span> ConnectionShutdownException)) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>throw</span> e.withSuppressed(recoveredFailures)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>          recoveredFailures <span style=color:#f92672>+=</span> e
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        newExchangeFinder = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Attach the prior response if it exists. Such responses never have a body.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (priorResponse <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        response = response.newBuilder()
</span></span><span style=display:flex><span>            .priorResponse(priorResponse.newBuilder()
</span></span><span style=display:flex><span>                .body(<span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                .build())
</span></span><span style=display:flex><span>            .build()
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> exchange = call.interceptorScopedExchange
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> followUp = followUpRequest(response, exchange)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (followUp <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (exchange <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> exchange.isDuplex) {
</span></span><span style=display:flex><span>          call.timeoutEarlyExit()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        closeActiveExchange = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> response
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> followUpBody = followUp.body
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (followUpBody <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> followUpBody.isOneShot()) {
</span></span><span style=display:flex><span>        closeActiveExchange = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> response
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      response.body<span style=color:#f92672>?.</span>closeQuietly()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>++</span>followUpCount &gt; MAX_FOLLOW_UPS) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> ProtocolException(<span style=color:#e6db74>&#34;Too many follow-up requests: </span><span style=color:#e6db74>$followUpCount</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      request = followUp
</span></span><span style=display:flex><span>      priorResponse = response
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>      call.exitNetworkInterceptorExchange(closeActiveExchange)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>recover</span>(
</span></span><span style=display:flex><span>  e: IOException,
</span></span><span style=display:flex><span>  call: RealCall,
</span></span><span style=display:flex><span>  userRequest: Request,
</span></span><span style=display:flex><span>  requestSendStarted: Boolean
</span></span><span style=display:flex><span>): Boolean {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// The application layer has forbidden retries.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (!client.retryOnConnectionFailure) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We can&#39;t send the request body again.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (requestSendStarted <span style=color:#f92672>&amp;&amp;</span> requestIsOneShot(e, userRequest)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// This exception is fatal.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!is</span>Recoverable(e, requestSendStarted)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// No more routes to attempt.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (!call.retryAfterFailure()) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// For failure recovery, use the same route selector with a new connection.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Throws</span>(IOException<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>followUpRequest</span>(userResponse: Response, exchange: Exchange?): Request? {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> route = exchange<span style=color:#f92672>?.</span>connection<span style=color:#f92672>?.</span>route()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> responseCode = userResponse.code
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> method = userResponse.request.method
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>when</span> (responseCode) {
</span></span><span style=display:flex><span>    HTTP_PROXY_AUTH <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> selectedProxy = route<span style=color:#f92672>!!</span>.proxy
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (selectedProxy.type() <span style=color:#f92672>!=</span> Proxy.Type.HTTP) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> ProtocolException(<span style=color:#e6db74>&#34;Received HTTP_PROXY_AUTH (407) code while not using proxy&#34;</span>)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> client.proxyAuthenticator.authenticate(route, userResponse)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HTTP_UNAUTHORIZED <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>return</span> client.authenticator.authenticate(route, userResponse)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> buildRedirectRequest(userResponse, method)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HTTP_CLIENT_TIMEOUT <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 408&#39;s are rare in practice, but some servers like HAProxy use this response code. The
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// spec says that we may repeat the request without modifications. Modern browsers also
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// repeat the request (even non-idempotent ones.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (!client.retryOnConnectionFailure) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The application layer has directed us not to retry the request.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> requestBody = userResponse.request.body
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (requestBody <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> requestBody.isOneShot()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> priorResponse = userResponse.priorResponse
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (priorResponse <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> priorResponse.code <span style=color:#f92672>==</span> HTTP_CLIENT_TIMEOUT) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We attempted to retry and got another timeout. Give up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (retryAfter(userResponse, <span style=color:#ae81ff>0</span>) &gt; <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> userResponse.request
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HTTP_UNAVAILABLE <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> priorResponse = userResponse.priorResponse
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (priorResponse <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> priorResponse.code <span style=color:#f92672>==</span> HTTP_UNAVAILABLE) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We attempted to retry and got another timeout. Give up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (retryAfter(userResponse, Integer.MAX_VALUE) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// specifically received an instruction to retry without delay
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> userResponse.request
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HTTP_MISDIRECTED_REQUEST <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// OkHttp can coalesce HTTP/2 connections even if the domain names are different. See
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// RealConnection.isEligible(). If we attempted this and the server returned HTTP 421, then
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// we can retry on a different connection.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>val</span> requestBody = userResponse.request.body
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (requestBody <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> requestBody.isOneShot()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (exchange <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> !exchange.isCoalescedConnection) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      exchange.connection.noCoalescedConnections()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> userResponse.request
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个过程的大致流程如下：</p><p><img src=https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035354.png width=auto alt></p><p>从上图中可以看出，RetryAndFollowUpInterceptor 开启了一个 while(true) 的循环，并在循环内部完成两个重要的判定，如图中的蓝色方框：</p><ol><li>当请求内部抛出异常时，判定是否需要重试</li><li>当响应结果是 3xx 重定向时，构建新的请求并发送请求</li></ol><p>重试的逻辑相对复杂，有如下的判定逻辑（具体代码在 RetryAndFollowUpInterceptor 类的 recover 方法）：</p><ul><li>规则 1: client 的 retryOnConnectionFailure 参数设置为 false，不进行重试</li><li>规则 2: 请求的 body 已经发出，不进行重试</li><li>规则 3: 特殊的异常类型不进行重试（如 ProtocolException，SSLHandshakeException 等）</li><li>规则 4: 没有更多的 route（包含 proxy 和 inetaddress），不进行重试</li></ul><h2 id=bridgeinterceptor>BridgeInterceptor
<a class=anchor href=#bridgeinterceptor>#</a></h2><p>负责一些不影响开发者开发，但影响 HTTP 交互的一些额外预处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Throws</span>(IOException<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>intercept</span>(chain: Interceptor.Chain): Response {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> userRequest = chain.request()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> requestBuilder = userRequest.newBuilder()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> body = userRequest.body
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (body <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> contentType = body.contentType()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (contentType <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      requestBuilder.header(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, contentType.toString())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> contentLength = body.contentLength()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (contentLength <span style=color:#f92672>!=</span> -<span style=color:#ae81ff>1L</span>) {
</span></span><span style=display:flex><span>      requestBuilder.header(<span style=color:#e6db74>&#34;Content-Length&#34;</span>, contentLength.toString())
</span></span><span style=display:flex><span>      requestBuilder.removeHeader(<span style=color:#e6db74>&#34;Transfer-Encoding&#34;</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      requestBuilder.header(<span style=color:#e6db74>&#34;Transfer-Encoding&#34;</span>, <span style=color:#e6db74>&#34;chunked&#34;</span>)
</span></span><span style=display:flex><span>      requestBuilder.removeHeader(<span style=color:#e6db74>&#34;Content-Length&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (userRequest.header(<span style=color:#e6db74>&#34;Host&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    requestBuilder.header(<span style=color:#e6db74>&#34;Host&#34;</span>, userRequest.url.toHostHeader())
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (userRequest.header(<span style=color:#e6db74>&#34;Connection&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    requestBuilder.header(<span style=color:#e6db74>&#34;Connection&#34;</span>, <span style=color:#e6db74>&#34;Keep-Alive&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// If we add an &#34;Accept-Encoding: gzip&#34; header field we&#39;re responsible for also decompressing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// the transfer stream.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> transparentGzip = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (userRequest.header(<span style=color:#e6db74>&#34;Accept-Encoding&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> userRequest.header(<span style=color:#e6db74>&#34;Range&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    transparentGzip = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    requestBuilder.header(<span style=color:#e6db74>&#34;Accept-Encoding&#34;</span>, <span style=color:#e6db74>&#34;gzip&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> cookies = cookieJar.loadForRequest(userRequest.url)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (cookies.isNotEmpty()) {
</span></span><span style=display:flex><span>    requestBuilder.header(<span style=color:#e6db74>&#34;Cookie&#34;</span>, cookieHeader(cookies))
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (userRequest.header(<span style=color:#e6db74>&#34;User-Agent&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    requestBuilder.header(<span style=color:#e6db74>&#34;User-Agent&#34;</span>, userAgent)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> networkResponse = chain.proceed(requestBuilder.build())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//收到响应后，存储 Cookie：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> responseBuilder = networkResponse.newBuilder()
</span></span><span style=display:flex><span>      .request(userRequest)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (transparentGzip <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;gzip&#34;</span>.equals(networkResponse.header(<span style=color:#e6db74>&#34;Content-Encoding&#34;</span>), ignoreCase = <span style=color:#66d9ef>true</span>) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>      networkResponse.promisesBody()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> responseBody = networkResponse.body
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (responseBody <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> gzipSource = GzipSource(responseBody.source())
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> strippedHeaders = networkResponse.headers.newBuilder()
</span></span><span style=display:flex><span>          .removeAll(<span style=color:#e6db74>&#34;Content-Encoding&#34;</span>)
</span></span><span style=display:flex><span>          .removeAll(<span style=color:#e6db74>&#34;Content-Length&#34;</span>)
</span></span><span style=display:flex><span>          .build()
</span></span><span style=display:flex><span>      responseBuilder.headers(strippedHeaders)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> contentType = networkResponse.header(<span style=color:#e6db74>&#34;Content-Type&#34;</span>)
</span></span><span style=display:flex><span>      responseBuilder.body(RealResponseBody(contentType, -<span style=color:#ae81ff>1L</span>, gzipSource.buffer()))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> responseBuilder.build()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>BridgeInterceptor 拦截器的功能如下：</p><ol><li>负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应，是从应用程序代码到网络代码的桥梁</li><li>设置内容长度，内容编码</li><li>设置 gzip 压缩，并在接收到内容后进行解压。省去了应用层处理数据解压的麻烦</li><li>添加 cookie</li><li>设置其他报头，如 Content-Length、User-Agent、Host、Keep-alive 等。其中 Keep-Alive 是实现连接复用的必要步骤</li></ol><h2 id=cacheinterceptor>CacheInterceptor
<a class=anchor href=#cacheinterceptor>#</a></h2><p>负责 Cache 的处理。把它放在后面的网络交互相关 Interceptor 的前面的好处是，如果本地有了可用的 Cache，一个请求可以在没有发生实质网络交互的情况下就返回缓存结果，而完全不需要开发者做出任何的额外工作，让 Cache 更加无感知。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Throws</span>(IOException<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>intercept</span>(chain: Interceptor.Chain): Response {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> call = chain.call()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> cacheCandidate = cache<span style=color:#f92672>?.</span><span style=color:#66d9ef>get</span>(chain.request())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> now = System.currentTimeMillis()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> networkRequest = strategy.networkRequest
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> cacheResponse = strategy.cacheResponse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cache<span style=color:#f92672>?.</span>trackResponse(strategy)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> listener = (call <span style=color:#66d9ef>as</span>? RealCall)<span style=color:#f92672>?.</span>eventListener <span style=color:#f92672>?:</span> EventListener.NONE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (cacheCandidate <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> cacheResponse <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The cache candidate wasn&#39;t applicable. Close it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cacheCandidate.body<span style=color:#f92672>?.</span>closeQuietly()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// If we&#39;re forbidden from using the network and the cache is insufficient, fail.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (networkRequest <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> cacheResponse <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Response.Builder()
</span></span><span style=display:flex><span>        .request(chain.request())
</span></span><span style=display:flex><span>        .protocol(Protocol.HTTP_1_1)
</span></span><span style=display:flex><span>        .code(HTTP_GATEWAY_TIMEOUT)
</span></span><span style=display:flex><span>        .message(<span style=color:#e6db74>&#34;Unsatisfiable Request (only-if-cached)&#34;</span>)
</span></span><span style=display:flex><span>        .body(EMPTY_RESPONSE)
</span></span><span style=display:flex><span>        .sentRequestAtMillis(-<span style=color:#ae81ff>1L</span>)
</span></span><span style=display:flex><span>        .receivedResponseAtMillis(System.currentTimeMillis())
</span></span><span style=display:flex><span>        .build().also {
</span></span><span style=display:flex><span>          listener.satisfactionFailure(call, <span style=color:#66d9ef>it</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// If we don&#39;t need the network, we&#39;re done.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (networkRequest <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cacheResponse<span style=color:#f92672>!!</span>.newBuilder()
</span></span><span style=display:flex><span>        .cacheResponse(stripBody(cacheResponse))
</span></span><span style=display:flex><span>        .build().also {
</span></span><span style=display:flex><span>          listener.cacheHit(call, <span style=color:#66d9ef>it</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (cacheResponse <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    listener.cacheConditionalHit(call, cacheResponse)
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (cache <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    listener.cacheMiss(call)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 没有命中缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> networkResponse: Response? = <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    networkResponse = chain.proceed(networkRequest)
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we&#39;re crashing on I/O or otherwise, don&#39;t leak the cache body.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (networkResponse <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> cacheCandidate <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      cacheCandidate.body<span style=color:#f92672>?.</span>closeQuietly()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果缓存策略中，网络响应和响应缓存都不为null，需要更新响应缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// (比如 需要向服务器确认缓存是否可用的情况)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// If we have a cache response too, then we&#39;re doing a conditional get.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (cacheResponse <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 304 的返回是不带 body 的,此时必须获取 cache 的 body
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (networkResponse<span style=color:#f92672>?.</span>code <span style=color:#f92672>==</span> HTTP_NOT_MODIFIED) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> response = cacheResponse.newBuilder()
</span></span><span style=display:flex><span>          .headers(combine(cacheResponse.headers, networkResponse.headers))
</span></span><span style=display:flex><span>          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
</span></span><span style=display:flex><span>          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
</span></span><span style=display:flex><span>          .cacheResponse(stripBody(cacheResponse))
</span></span><span style=display:flex><span>          .networkResponse(stripBody(networkResponse))
</span></span><span style=display:flex><span>          .build()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      networkResponse.body<span style=color:#f92672>!!</span>.close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Update the cache after combining headers but before stripping the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// Content-Encoding header (as performed by initContentStream()).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      cache<span style=color:#f92672>!!</span>.trackConditionalCacheHit()
</span></span><span style=display:flex><span>      cache.update(cacheResponse, response)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> response.also {
</span></span><span style=display:flex><span>        listener.cacheHit(call, <span style=color:#66d9ef>it</span>)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      cacheResponse.body<span style=color:#f92672>?.</span>closeQuietly()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 构建响应对象，等待返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> response = networkResponse<span style=color:#f92672>!!</span>.newBuilder()
</span></span><span style=display:flex><span>      .cacheResponse(stripBody(cacheResponse))
</span></span><span style=display:flex><span>      .networkResponse(stripBody(networkResponse))
</span></span><span style=display:flex><span>      .build()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (cache <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将请求放到缓存中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (response.promisesBody() <span style=color:#f92672>&amp;&amp;</span> CacheStrategy.isCacheable(response, networkRequest)) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Offer this request to the cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>val</span> cacheRequest = cache.put(response)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> cacheWritingResponse(cacheRequest, response).also {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cacheResponse <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// This will log a conditional cache miss only.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          listener.cacheMiss(call)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果请求不能被缓存，则移除该请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (HttpMethod.invalidatesCache(networkRequest.method)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        cache.remove(networkRequest)
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (_: IOException) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The cache cannot be written.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> response
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个过程的流程如下：</p><ol><li>通过 Request 尝试到 Cache 中拿缓存，当然前提是 OkHttpClient 中配置了缓存，默认是不支持的。</li><li>根据 response、time、request 创建一个缓存策略，用于判断怎样使用缓存。</li><li>如果缓存策略中设置禁止使用网络，并且缓存又为空，则构建一个 Response 直接返回（返回码为 504）</li><li>缓存策略中设置不使用网络，但是又缓存，直接返回缓存</li><li>接着走后续过滤器的流程，chain.proceed(networkRequest)</li><li>当缓存存在的时候，如果网络返回的 Response 为 304，则使用缓存的 Response。</li><li>构建网络请求的 Response</li><li>当在 OkHttpClient 中配置了缓存，则将这个 Response 缓存起来。</li><li>缓存起来的步骤也是先缓存 header，再缓存 body。</li><li>返回 Response</li></ol><h2 id=connectinterceptor>ConnectInterceptor
<a class=anchor href=#connectinterceptor>#</a></h2><p>负责建立连接，它的源码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>ConnectInterceptor</span> : Interceptor {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Throws</span>(IOException<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>intercept</span>(chain: Interceptor.Chain): Response {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> realChain = chain <span style=color:#66d9ef>as</span> RealInterceptorChain
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> exchange = realChain.call.initExchange(chain)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> connectedChain = realChain.copy(exchange = exchange)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//开始下一个拦截器的工作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> connectedChain.proceed(realChain.request)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个类本身很简单，从源码来看，关键的代码只有注释 1 处的那一句。它的作用是：从 RealCall 中获得了一个新的 ExChange 的对象。跟踪它的执行，可以发现它有如下调用逻辑：</p><p><img src=https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035402.png width=auto alt></p><p>在这个步骤中，ConnectInterceptor 最终会通过 Socket 创建出网络请求所需要的 TCP 连接（如果是 HTTP），或者是建立在 TCP 连接之上的 TLS 连接（如果是 HTTPS）。并且会创建出对应的 HttpCodec 对象 （用于编码解码 HTTP 请求），并且最终封装成 Exchange 对象并返回。</p><h2 id=clientnetworkinterceptors>client.networkInterceptors
<a class=anchor href=#clientnetworkinterceptors>#</a></h2><p>client.networkInterceptors 是由开发者使用 addNetworkInterceptor(Interceptor) 所设置的，它们的行为逻辑和使用 addInterceptor(Interceptor) 创建的一样，但由于位置不同，所以这里创建的 Interceptor 会看到每个请求和响应的数据（包括重定向以及重试的一些中间请求和响应），并且看到的是完整原始数据，而不是没有加 Content-Length 的请求数据，或者 Body 还没有被 gzip 解压的响应数据。多数情况，这个方法不需要被使用，不过如果需要做网络调试，可以用它来实现。</p><h2 id=callserverinterceptor>CallServerInterceptor
<a class=anchor href=#callserverinterceptor>#</a></h2><p>CalllServerInterceptor 是最后一个拦截器了，它负责实质的请求与响应的 I/O 操作，即：往 Socket 里写入请求数据和从 Socket 里读取响应数据，进行 http 请求报文的封装与请求报文的解析。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Throws</span>(IOException<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>intercept</span>(chain: Interceptor.Chain): Response {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> realChain = chain <span style=color:#66d9ef>as</span> RealInterceptorChain
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> exchange = realChain.exchange<span style=color:#f92672>!!</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> request = realChain.request
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> requestBody = request.body
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> sentRequestMillis = System.currentTimeMillis()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  exchange.writeRequestHeaders(request)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> invokeStartEvent = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> responseBuilder: Response.Builder? = <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (HttpMethod.permitsRequestBody(request.method) <span style=color:#f92672>&amp;&amp;</span> requestBody <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If there&#39;s a &#34;Expect: 100-continue&#34; header on the request, wait for a &#34;HTTP/1.1 100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Continue&#34; response before transmitting the request body. If we don&#39;t get that, return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// what we did get (such as a 4xx response) without ever transmitting the request body.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;100-continue&#34;</span>.equals(request.header(<span style=color:#e6db74>&#34;Expect&#34;</span>), ignoreCase = <span style=color:#66d9ef>true</span>)) {
</span></span><span style=display:flex><span>      exchange.flushRequest()
</span></span><span style=display:flex><span>      responseBuilder = exchange.readResponseHeaders(expectContinue = <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>      exchange.responseHeadersStart()
</span></span><span style=display:flex><span>      invokeStartEvent = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (responseBuilder <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (requestBody.isDuplex()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Prepare a duplex body so that the application can send a request body later.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        exchange.flushRequest()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> bufferedRequestBody = exchange.createRequestBody(request, <span style=color:#66d9ef>true</span>).buffer()
</span></span><span style=display:flex><span>        requestBody.writeTo(bufferedRequestBody)
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Write the request body if the &#34;Expect: 100-continue&#34; expectation was met.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>val</span> bufferedRequestBody = exchange.createRequestBody(request, <span style=color:#66d9ef>false</span>).buffer()
</span></span><span style=display:flex><span>        requestBody.writeTo(bufferedRequestBody)
</span></span><span style=display:flex><span>        bufferedRequestBody.close()
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      exchange.noRequestBody()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (!exchange.connection.isMultiplexed) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If the &#34;Expect: 100-continue&#34; expectation wasn&#39;t met, prevent the HTTP/1 connection
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// from being reused. Otherwise we&#39;re still obligated to transmit the request body to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// leave the connection in a consistent state.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        exchange.noNewExchangesOnConnection()
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    exchange.noRequestBody()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (requestBody <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> !requestBody.isDuplex()) {
</span></span><span style=display:flex><span>    exchange.finishRequest()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (responseBuilder <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    responseBuilder = exchange.readResponseHeaders(expectContinue = <span style=color:#66d9ef>false</span>)<span style=color:#f92672>!!</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (invokeStartEvent) {
</span></span><span style=display:flex><span>      exchange.responseHeadersStart()
</span></span><span style=display:flex><span>      invokeStartEvent = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> response = responseBuilder
</span></span><span style=display:flex><span>      .request(request)
</span></span><span style=display:flex><span>      .handshake(exchange.connection.handshake())
</span></span><span style=display:flex><span>      .sentRequestAtMillis(sentRequestMillis)
</span></span><span style=display:flex><span>      .receivedResponseAtMillis(System.currentTimeMillis())
</span></span><span style=display:flex><span>      .build()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> code = response.code
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (code <span style=color:#f92672>==</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Server sent a 100-continue even though we did not request one. Try again to read the actual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// response status.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    responseBuilder = exchange.readResponseHeaders(expectContinue = <span style=color:#66d9ef>false</span>)<span style=color:#f92672>!!</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (invokeStartEvent) {
</span></span><span style=display:flex><span>      exchange.responseHeadersStart()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    response = responseBuilder
</span></span><span style=display:flex><span>        .request(request)
</span></span><span style=display:flex><span>        .handshake(exchange.connection.handshake())
</span></span><span style=display:flex><span>        .sentRequestAtMillis(sentRequestMillis)
</span></span><span style=display:flex><span>        .receivedResponseAtMillis(System.currentTimeMillis())
</span></span><span style=display:flex><span>        .build()
</span></span><span style=display:flex><span>    code = response.code
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  exchange.responseHeadersEnd(response)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  response = <span style=color:#66d9ef>if</span> (forWebSocket <span style=color:#f92672>&amp;&amp;</span> code <span style=color:#f92672>==</span> <span style=color:#ae81ff>101</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Connection is upgrading, but we need to ensure interceptors see a non-null response body.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    response.newBuilder()
</span></span><span style=display:flex><span>        .body(EMPTY_RESPONSE)
</span></span><span style=display:flex><span>        .build()
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    response.newBuilder()
</span></span><span style=display:flex><span>        .body(exchange.openResponseBody(response))
</span></span><span style=display:flex><span>        .build()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;close&#34;</span>.equals(response.request.header(<span style=color:#e6db74>&#34;Connection&#34;</span>), ignoreCase = <span style=color:#66d9ef>true</span>) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;close&#34;</span>.equals(response.header(<span style=color:#e6db74>&#34;Connection&#34;</span>), ignoreCase = <span style=color:#66d9ef>true</span>)) {
</span></span><span style=display:flex><span>    exchange.noNewExchangesOnConnection()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ((code <span style=color:#f92672>==</span> <span style=color:#ae81ff>204</span> <span style=color:#f92672>||</span> code <span style=color:#f92672>==</span> <span style=color:#ae81ff>205</span>) <span style=color:#f92672>&amp;&amp;</span> response.body<span style=color:#f92672>?.</span>contentLength() <span style=color:#f92672>?:</span> -<span style=color:#ae81ff>1L</span> &gt; <span style=color:#ae81ff>0L</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> ProtocolException(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;HTTP </span><span style=color:#e6db74>$code</span><span style=color:#e6db74> had non-zero Content-Length: </span><span style=color:#e6db74>${response.body?.contentLength()}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> response
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>CallServerInterceptor 由以下步骤组成：</p><ol><li>向服务器发送 request header</li><li>如果有 request body，就向服务器发送</li><li>读取 response header，先构造一个 Response 对象</li><li>如果有 response body，就在 3 的基础上加上 body 构造一个新的 Response 对象</li></ol><p>可以看到，核心工作都由 <strong>HttpCodec</strong> 对象完成，而 HttpCodec 实际上利用的是 Okio，而 Okio 实际上还是用的 Socket，只不过是经过了层层嵌套。</p><h1 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h1><p><img src=https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035408.png width=auto alt></p><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://guanpj.github.io/amethyst/quartz/js/graph.cbd78cfa87df7d3e230d16fc24f06548.js></script></div></div><div id=contact_buttons><footer><p>Made with <a href=https://github.com/64bitpandas/amethyst>Amethyst</a>, © 2023 guanpj</p><ul><li><a href=https://guanpj.github.io/amethyst/>Home</a></li><li><a href=https://bencuan.me>Website</a></li><li><a href=https://blog.bencuan.me>Blog</a></li></ul></footer></div></article><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#请求流程>请求流程</a><ul><li><a href=#strong同步请求strong><strong>同步请求</strong></a></li><li><a href=#strong异步请求strong><strong>异步请求</strong></a></li><li><a href=#getresponsewithinterceptorchain>getResponseWithInterceptorChain</a></li></ul></li><li><a href=#okhttpclient>OkHttpClient</a></li><li><a href=#strongrequest-和-responsestrong><strong>Request 和 Response</strong></a></li><li><a href=#realcall>RealCall</a></li><li><a href=#interceptor>Interceptor</a><ul><li><a href=#clientinterceptors>client.interceptors</a></li><li><a href=#retryandfollowupinterceptor>RetryAndFollowUpInterceptor</a></li><li><a href=#bridgeinterceptor>BridgeInterceptor</a></li><li><a href=#cacheinterceptor>CacheInterceptor</a></li><li><a href=#connectinterceptor>ConnectInterceptor</a></li><li><a href=#clientnetworkinterceptors>client.networkInterceptors</a></li><li><a href=#callserverinterceptor>CallServerInterceptor</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></main></body></html>