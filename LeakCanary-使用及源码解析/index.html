<!doctype html><html lang=en dir=ltr><head><meta property="og:title" content="LeakCanary 使用及源码解析"><meta property="og:description" content="Reference 介绍 #  Reference 即是我们平时所说的“引用”，与之对应的是一个泛型抽象类。四种引用类型：SoftReference(软引用)、WeakReference(弱引用)、PhantomReference（虚引用）都继承自 Reference。它的声明如下：
public abstract class Reference<T> {  //引用对象  volatile T referent;  //保存即将被回收的Reference对象  final ReferenceQueue<? super T> queue;   //在Enqueued状态下即引用加入队列时，指向下一个待处理Reference对象,默认为null  Reference queueNext;  //在Pending状态下，待入列引用，默认为null  Reference<?> pendingNext;   ... } Reference 有四种状态：Active、Pending、Enqueued、Inactive，默认为 Active 状态。
ReferenceQueue 则是一个单向链表实现的队列数据结构，存储的是 Reference 对象。包含了入列 enqueue、出列 poll 和移除 remove 操作。
ReferenceQueue 原理和使用示例 #  Reference 配合 ReferenceQueue 可以实现对象回收监听，使用方法如下：
//创建一个引用队列 ReferenceQueue queue = new ReferenceQueue(); //创建对象 Object object = new Object(); //创建 object 对象的弱引用，并关联引用队列 queue WeakReference reference = new WeakReference(object, queue); System."><meta property="og:type" content="article"><meta property="og:url" content="https://guanpj.github.io/amethyst/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><meta property="article:section" content><meta property="og:site_name" content="guanpj's blog"><title>LeakCanary 使用及源码解析 | guanpj's blog</title><link rel=manifest href=/amethyst/manifest.json><link rel=icon href=/amethyst/favicon.png type=image/x-icon><link rel=stylesheet href=/amethyst/book.min.c27ff4755c78daab11627953d5a6dd7e2698690e086398032995aae74d6397b6.css integrity="sha256-wn/0dVx42qsRYnlT1abdfiaYaQ4IY5gDKZWq501jl7Y=" crossorigin=anonymous><meta charset=utf-8><meta name=description content="Reference 介绍 #  Reference 即是我们平时所说的“引用”，与之对应的是一个泛型抽象类。四种引用类型：SoftReference(软引用)、WeakReference(弱引用)、PhantomReference（虚引用）都继承自 Reference。它的声明如下：
public abstract class Reference<T> {  //引用对象  volatile T referent;  //保存即将被回收的Reference对象  final ReferenceQueue<? super T> queue;   //在Enqueued状态下即引用加入队列时，指向下一个待处理Reference对象,默认为null  Reference queueNext;  //在Pending状态下，待入列引用，默认为null  Reference<?> pendingNext;   ... } Reference 有四种状态：Active、Pending、Enqueued、Inactive，默认为 Active 状态。
ReferenceQueue 则是一个单向链表实现的队列数据结构，存储的是 Reference 对象。包含了入列 enqueue、出列 poll 和移除 remove 操作。
ReferenceQueue 原理和使用示例 #  Reference 配合 ReferenceQueue 可以实现对象回收监听，使用方法如下：
//创建一个引用队列 ReferenceQueue queue = new ReferenceQueue(); //创建对象 Object object = new Object(); //创建 object 对象的弱引用，并关联引用队列 queue WeakReference reference = new WeakReference(object, queue); System."><title>LeakCanary 使用及源码解析</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://guanpj.github.io/amethyst//favicon.png><link href=https://guanpj.github.io/amethyst/styles.e08ceb33360cec132feb69cfb982e2a4.min.css rel=stylesheet><link href=https://guanpj.github.io/amethyst/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://guanpj.github.io/amethyst/quartz/js/darkmode.1bc498b60ed24d8858f74f99e480db82.min.js></script>
<script src=https://guanpj.github.io/amethyst/quartz/js/util.c69e233dc1cc331a30b0f670e657b425.min.js></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://guanpj.github.io/amethyst/quartz/js/popover.f03552ccb84d99ca615d1cfb9abde59e.min.js></script>
<script defer src=https://guanpj.github.io/amethyst/quartz/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://guanpj.github.io/amethyst/quartz/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://guanpj.github.io/amethyst/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://guanpj.github.io/amethyst/",fetchData=Promise.all([fetch("https://guanpj.github.io/amethyst/indices/linkIndex.a0cf85a144674d956ca9db3dfb7745ab.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://guanpj.github.io/amethyst/indices/contentIndex.6e36d79b0a0d4a81007275dd2fa73365.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://guanpj.github.io/amethyst",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://guanpj.github.io/amethyst",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://guanpj.github.io/amethyst/quartz/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><header class=book-header><label for=menu-control><img src=/amethyst/svg/menu.svg class=book-icon alt=Menu></label><h1 id=page-title><a href=https://guanpj.github.io/amethyst/>guanpj's blog</a></h1><div class=spacer></div><div id=search-icon class=quartz-search><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control><main class=flex><aside class=book-menu><div class=book-menu-content><nav><div class=menu-search><div id=search-icon class=quartz-search><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div></div><ul><li><a href=/amethyst/2023-03-15/>2023 03 15</a></li><li><a href=/amethyst/2023-03-18/>2023 03 18</a></li><li><a href=/amethyst/2023-03-19/>2023 03 19</a></li><li><a href=/amethyst/2023-03-20/>2023 03 20</a></li><li><a href=/amethyst/Buttons/>Buttons</a></li><li><a href=/amethyst/ControlPanel/>Control Panel</a></li><li><a href=/amethyst/Linter/>Linter</a></li><li><a href=/amethyst/MyDraw/>My Draw</a></li><li><a href=/amethyst/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88/>其他模版</a></li><li><a href=/amethyst/%E5%A7%94%E6%89%98/>委托</a></li><li><a href=/amethyst/%E5%BC%95%E7%94%A8/>引用</a></li><li><a href=/amethyst/%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/>扩展函数</a></li><li><a href=/amethyst/%E6%8C%87%E9%92%88/>指针</a></li><li><a href=/amethyst/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2/>文件读取、文本替换</a></li><li><a href=/amethyst/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8/>类的定义、使用</a></li><li><a href=/amethyst/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D/>遍历文件、重命名</a></li><li><a href=/amethyst/About-Atlas/>About Atlas</a></li><li><a href=/amethyst/ADB-%E5%91%BD%E4%BB%A4/>ADB 命令</a></li><li><a href=/amethyst/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/>ADB 命令</a></li><li><a href=/amethyst/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96/>Android 对容器类的优化</a></li><li><a href=/amethyst/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/>CAS 和 AQS 原理</a></li><li><a href=/amethyst/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>EventBus 使用及源码解析</a></li><li><a href=/amethyst/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/>Glide 加载流程和缓存原理分析</a></li><li><a href=/amethyst/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/>Glide 基本使用</a></li><li><a href=/amethyst/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/>Glide 高级用法</a></li><li><a href=/amethyst/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>HashMap 源码解析</a></li><li><a href=/amethyst/HTTP-%E5%9F%BA%E7%A1%80/>HTTP 基础</a></li><li><a href=/amethyst/Index-for-Atlases/>Index for Atlases</a></li><li><a href=/amethyst/Index-for-Extras/>Index for Extras</a></li><li><a href=/amethyst/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/>Java 内存模型</a></li><li><a href=/amethyst/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>JVM 中的对象和垃圾回收</a></li><li><a href=/amethyst/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/>JVM 内存区域</a></li><li><a href=/amethyst/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/>JVM 字节码指令简介</a></li><li><a href=/amethyst/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/>JVM 字节码结构分析</a></li><li><a href=/amethyst/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/>JVM 类加载机制</a></li><li><a href=/amethyst/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/ class=active>LeakCanary 使用及源码解析</a></li><li><a href=/amethyst/MyIdeas/>MyIdeas</a></li><li><a href=/amethyst/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>OkHttp 使用及源码分析</a></li><li><a href=/amethyst/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>Retrofit 使用及源码分析</a></li><li><a href=/amethyst/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>RxJava 使用及源码分析</a></li><li><a href=/amethyst/2023-03-22/>Troubleshooting and FAQ</a></li><li><a href=/amethyst/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87/>一、Binder 机制分析——概念篇</a></li><li><a href=/amethyst/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/>七、View 事件机制分析</a></li><li><a href=/amethyst/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/>三、Handler 原理分析</a></li><li><a href=/amethyst/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87/>二、Binder 机制分析——应用篇</a></li><li><a href=/amethyst/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/>二叉树遍历</a></li><li><a href=/amethyst/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>五、App 启动流程分析</a></li><li><a href=/amethyst/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>六、View 绘制流程分析</a></li><li><a href=/amethyst/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>四、系统启动流程分析</a></li><li><a href=/amethyst/%E5%AE%B9%E5%99%A8%E7%B1%BB/>容器类</a></li><li><a href=/amethyst/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/>并发容器</a></li><li><a href=/amethyst/%E6%B3%9B%E5%9E%8B/>泛型</a></li><li><a href=/amethyst/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/>注解和反射</a></li><li><a href=/amethyst/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/>等待-通知机制</a></li><li><a href=/amethyst/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/>线程协作</a></li><li><a href=/amethyst/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/>线程基础</a></li><li><a href=/amethyst/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue/>线程池和 BlockingQueue</a></li><li><a href=/amethyst/%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/>编码、加密、Hash、序列化和字符集</a></li><li><a href=/amethyst/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84TCPIP-%E5%92%8C-HTTPS/>计算机网络体系结构、TCP&IP 和 HTTPS</a></li><li><a href=/amethyst/%E9%94%81/>锁</a></li></ul><ul><li><a href=https://github.com/64bitpandas/amethyst target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class="book-page container"><article class=markdown><h1 class=title>LeakCanary 使用及源码解析</h1><h1 id=reference-介绍>Reference 介绍
<a class=anchor href=#reference-%e4%bb%8b%e7%bb%8d>#</a></h1><p>Reference 即是我们平时所说的“引用”，与之对应的是一个泛型抽象类。四种引用类型：SoftReference(软引用)、WeakReference(弱引用)、PhantomReference（虚引用）都继承自 Reference。它的声明如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Reference</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//引用对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>volatile</span> T referent<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//保存即将被回收的Reference对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> ReferenceQueue<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> queue<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在Enqueued状态下即引用加入队列时，指向下一个待处理Reference对象,默认为null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Reference queueNext<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在Pending状态下，待入列引用，默认为null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Reference<span style=color:#f92672>&lt;?&gt;</span> pendingNext<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Reference 有四种状态：Active、Pending、Enqueued、Inactive，默认为 Active 状态。</p><p>ReferenceQueue 则是一个单向链表实现的队列数据结构，存储的是 Reference 对象。包含了入列 enqueue、出列 poll 和移除 remove 操作。</p><h1 id=referencequeue-原理和使用示例>ReferenceQueue 原理和使用示例
<a class=anchor href=#referencequeue-%e5%8e%9f%e7%90%86%e5%92%8c%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b>#</a></h1><p>Reference 配合 ReferenceQueue 可以实现对象回收监听，使用方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//创建一个引用队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ReferenceQueue queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReferenceQueue<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//创建对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Object object <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//创建 object 对象的弱引用，并关联引用队列 queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>WeakReference reference <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WeakReference<span style=color:#f92672>(</span>object<span style=color:#f92672>,</span> queue<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>reference<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>gc</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//当 reference 被成功回收后，可以从 queue 中获取到该引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>queue<span style=color:#f92672>.</span><span style=color:#a6e22e>remove</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>输出结果<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ref</span><span style=color:#f92672>.</span><span style=color:#a6e22e>WeakReference</span><span style=color:#a6e22e>@3d833955</span>
</span></span><span style=display:flex><span>java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ref</span><span style=color:#f92672>.</span><span style=color:#a6e22e>WeakReference</span><span style=color:#a6e22e>@3d833955</span>
</span></span></code></pre></div><p>示例中的对象当然是可以正常回收的，所以回收后可以在关联的引用队列 queue 中获取到该引用。反之，若某个应该被回收的对象，GC 结束后在 queue 中未找到该引用，则表明该引用存在内存泄漏风险，这也就是 LeakCanary 的基本原理。</p><h1 id=leakcanary-基本使用>LeakCanary 基本使用
<a class=anchor href=#leakcanary-%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8>#</a></h1><h2 id=20-之前>2.0 之前
<a class=anchor href=#20-%e4%b9%8b%e5%89%8d>#</a></h2><p>导入依赖：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:1.6.1&#39;
</span></span><span style=display:flex><span>releaseImplementation &#39;com.squareup.leakcanary:leakcanary-android-no-op:1.6.1&#39;
</span></span><span style=display:flex><span>debugImplementation &#39;com.squareup.leakcanary:leakcanary-support-fragment:1.6.1&#39;
</span></span></code></pre></div><p>在项目的自定义 Application 中进行初始化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>initLeakCanary</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (LeakCanary.isInAnalyzerProcess(<span style=color:#66d9ef>this</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    LeakCanary.install(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=20-开始>2.0 开始
<a class=anchor href=#20-%e5%bc%80%e5%a7%8b>#</a></h2><p>LeakCanary 从 2.0 开始采用 Kotlin 编写，并且只需要导入依赖即可，不用再手动进行初始化操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.7&#39;
</span></span></code></pre></div><p>并且 Leakcanary 2.0 版本还增加了 shark 模块，用于 dumpFile 分析，相比于之前的方法大幅减少了内存的占用。</p><p>接下来的分析流程也是基于 2.7 版本进行的。</p><h1 id=leakcanary-原理分析>LeakCanary 原理分析
<a class=anchor href=#leakcanary-%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90>#</a></h1><h2 id=初始化>初始化
<a class=anchor href=#%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h2><p>既然不用手动初始化，那必定有自动初始化的入口。在 leakcanary-object-watcher-android 模块的
<a href=https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/AndroidManifest.xml rel=noopener>Manifest 文件</a> 中声明了一个 Provider 组件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;application&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;provider</span>
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>android:name=</span><span style=color:#e6db74>&#34;leakcanary.internal.AppWatcherInstaller$MainProcess&#34;</span>
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>android:authorities=</span><span style=color:#e6db74>&#34;${applicationId}.leakcanary-installer&#34;</span>
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>android:enabled=</span><span style=color:#e6db74>&#34;@bool/leak_canary_watcher_auto_install&#34;</span>
</span></span><span style=display:flex><span>	    <span style=color:#a6e22e>android:exported=</span><span style=color:#e6db74>&#34;false&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/application&gt;</span>
</span></span></code></pre></div><p>顺蔓摸瓜，查看 AppWatcherInstaller：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(): Boolean {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> application = context<span style=color:#f92672>!!</span>.applicationContext <span style=color:#66d9ef>as</span> Application
</span></span><span style=display:flex><span>  AppWatcher.manualInstall(application)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>果然找到了初始化方法，接着跟踪 AppWatcher 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@JvmOverloads</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>manualInstall</span>(
</span></span><span style=display:flex><span>  application: Application,
</span></span><span style=display:flex><span>  retainedDelayMillis: Long = TimeUnit.SECONDS.toMillis(<span style=color:#ae81ff>5</span>),
</span></span><span style=display:flex><span>  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//1、确保在主线程，否则抛出UnsupportedOperationException异常
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  checkMainThread()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (isInstalled) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> IllegalStateException(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;AppWatcher already installed, see exception cause for prior install call&#34;</span>, installCause
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  check(retainedDelayMillis <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;retainedDelayMillis </span><span style=color:#e6db74>$retainedDelayMillis</span><span style=color:#e6db74> must be at least 0 ms&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  installCause = RuntimeException(<span style=color:#e6db74>&#34;manualInstall() first called here&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.retainedDelayMillis = retainedDelayMillis
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (application.isDebuggableBuild) {
</span></span><span style=display:flex><span>    LogcatSharkLog.install()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//2、Requires AppWatcher.objectWatcher to be set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  LeakCanaryDelegate.loadLeakCanary(application)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//3、初始化 Activity 和 Fragment 监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  watchersToInstall.forEach {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>it</span>.install()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>跟踪注释 2 处：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>LeakCanaryDelegate</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//使用 lazy 实现懒汉单例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>@Suppress</span>(<span style=color:#e6db74>&#34;UNCHECKED_CAST&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> loadLeakCanary <span style=color:#66d9ef>by</span> lazy {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//反射调用 InternalLeakCanary
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>val</span> leakCanaryListener = Class.forName(<span style=color:#e6db74>&#34;leakcanary.internal.InternalLeakCanary&#34;</span>)
</span></span><span style=display:flex><span>      leakCanaryListener.getDeclaredField(<span style=color:#e6db74>&#34;INSTANCE&#34;</span>)
</span></span><span style=display:flex><span>        .<span style=color:#66d9ef>get</span>(<span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>as</span> (Application) <span style=color:#f92672>-&gt;</span> Unit
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (ignored: Throwable) {
</span></span><span style=display:flex><span>      NoLeakCanary
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>NoLeakCanary</span> : (Application) <span style=color:#f92672>-&gt;</span> Unit, OnObjectRetainedListener {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>invoke</span>(application: Application) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onObjectRetained</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接着查看 InternalLeakCanary 的 invoke 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>invoke</span>(application: Application) {
</span></span><span style=display:flex><span>  _application = application
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  checkRunningInDebuggableBuild()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//为 objectWatcher 对象添加 this 作为对象保留监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  AppWatcher.objectWatcher.addOnObjectRetainedListener(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//初始化 AndroidHeapDumper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))
</span></span><span style=display:flex><span>  <span style=color:#75715e>//GcTrigger
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> gcTrigger = GcTrigger.Default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> configProvider = { LeakCanary.config }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//初始化 backgroundHandler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)
</span></span><span style=display:flex><span>  handlerThread.start()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> backgroundHandler = Handler(handlerThread.looper)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//初始化 HeapDumpTrigger
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  heapDumpTrigger = HeapDumpTrigger(
</span></span><span style=display:flex><span>    application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,
</span></span><span style=display:flex><span>    configProvider
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>//监听 app 进入后台/返回前台事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  application.registerVisibilityListener { applicationVisible <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.applicationVisible = applicationVisible
</span></span><span style=display:flex><span>    heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  registerResumedActivityListener(application)
</span></span><span style=display:flex><span>  addDynamicShortcut(application)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We post so that the log happens after Application.onCreate()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  mainHandler.post {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// https://github.com/square/leakcanary/issues/1981
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// We post to a background handler because HeapDumpControl.iCanHasHeap() checks a shared pref
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// which blocks until loaded and that creates a StrictMode violation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    backgroundHandler.post {
</span></span><span style=display:flex><span>      SharkLog.d {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>when</span> (<span style=color:#66d9ef>val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>is</span> Yup <span style=color:#f92672>-&gt;</span> application.getString(R.string.leak_canary_heap_dump_enabled_text)
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>is</span> Nope <span style=color:#f92672>-&gt;</span> application.getString(
</span></span><span style=display:flex><span>            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()
</span></span><span style=display:flex><span>          )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至此，InternalLeakCanary 初始化完成。回到 manualInstall 方法中继续查看注释 3 处代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>watchersToInstall.forEach {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>it</span>.install()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>watchersToInstall 来自 appDefaultWatchers 方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>appDefaultWatchers</span>(
</span></span><span style=display:flex><span>  application: Application,
</span></span><span style=display:flex><span>  reachabilityWatcher: ReachabilityWatcher = objectWatcher
</span></span><span style=display:flex><span>): List&lt;InstallableWatcher&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> listOf(
</span></span><span style=display:flex><span>    ActivityWatcher(application, reachabilityWatcher),
</span></span><span style=display:flex><span>    FragmentAndViewModelWatcher(application, reachabilityWatcher),
</span></span><span style=display:flex><span>    RootViewWatcher(reachabilityWatcher),
</span></span><span style=display:flex><span>    ServiceWatcher(reachabilityWatcher)
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以 ActivityWatcher 为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ActivityWatcher</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> application: Application,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> reachabilityWatcher: ReachabilityWatcher
</span></span><span style=display:flex><span>) : InstallableWatcher {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> lifecycleCallbacks =
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>object</span> <span style=color:#960050;background-color:#1e0010>: </span><span style=color:#a6e22e>Application</span>.ActivityLifecycleCallbacks <span style=color:#66d9ef>by</span> noOpDelegate() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onActivityDestroyed</span>(activity: Activity) {
</span></span><span style=display:flex><span>        reachabilityWatcher.expectWeaklyReachable(
</span></span><span style=display:flex><span>          activity, <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${activity::class.java.name}</span><span style=color:#e6db74> received Activity#onDestroy() callback&#34;</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>install</span>() {
</span></span><span style=display:flex><span>    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>uninstall</span>() {
</span></span><span style=display:flex><span>    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>install 方法将 lifecycleCallbacks 注册为 application 的 ActivityLifecycleCallbacks，用来感知所有 Activity 的声明周期。</p><p>by noOpDelegate() 通过类委托机制将其他回调实现都交给 noOpDelegate，而 noOpDelegate 是一个空实现的动态代理。这里只需要监听 Activity 销毁事件，因此只需要重写 onActivityDestroyed 即可。</p><h2 id=activity-回收监听>Activity 回收监听
<a class=anchor href=#activity-%e5%9b%9e%e6%94%b6%e7%9b%91%e5%90%ac>#</a></h2><p>在 onActivityDestroyed 方法被回调时，调用了 reachabilityWatcher 的 expectWeaklyReachable 方法并将 activity 对象传进去。这里 reachabilityWatcher 的唯一实现类为 ObjectWatcher，查看它的 expectWeaklyReachable 方法内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Synchronized</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>expectWeaklyReachable</span>(
</span></span><span style=display:flex><span>  watchedObject: Any,
</span></span><span style=display:flex><span>  description: String
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!is</span>Enabled()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//将 ReferenceQueue 中出现的弱引用移除，即忽略已被回收的 Activity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  removeWeaklyReachableObjects()
</span></span><span style=display:flex><span>  <span style=color:#75715e>//生成随机的 key 值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> key = UUID.randomUUID().toString()
</span></span><span style=display:flex><span>  <span style=color:#75715e>//记录时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> watchUptimeMillis = clock.uptimeMillis()
</span></span><span style=display:flex><span>  <span style=color:#75715e>//将 Activity 对象（watchedObject）封装成 KeyedWeakReference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//并关联引用队列 queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> reference =
</span></span><span style=display:flex><span>    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)
</span></span><span style=display:flex><span>  SharkLog.d {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Watching &#34;</span> +
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>if</span> (watchedObject <span style=color:#66d9ef>is</span> Class&lt;*&gt;) watchedObject.toString() <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;instance of </span><span style=color:#e6db74>${watchedObject.javaClass.name}</span><span style=color:#e6db74>&#34;</span>) +
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>if</span> (description.isNotEmpty()) <span style=color:#e6db74>&#34; (</span><span style=color:#e6db74>$description</span><span style=color:#e6db74>)&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;&#34;</span>) +
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34; with key </span><span style=color:#e6db74>$key</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//将弱引用 reference 存入监听 map 集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  watchedObjects[key] = reference
</span></span><span style=display:flex><span>  <span style=color:#75715e>//5 秒之后在主线程执行 moveToRetained(key) 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  checkRetainedExecutor.execute {
</span></span><span style=display:flex><span>    moveToRetained(key)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>removeWeaklyReachableObjects</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// WeakReferences are enqueued as soon as the object to which they point to becomes weakly
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// reachable. This is before finalization or garbage collection has actually happened.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> ref: KeyedWeakReference?
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//从 queue 中取出对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ref = queue.poll() <span style=color:#66d9ef>as</span> KeyedWeakReference?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ref <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//将该对象从集合中移除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      watchedObjects.remove(ref.key)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>while</span> (ref <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为什么会是 5 秒，这里猜测与 Android GC 有关。在 Activity.H 中，收到 GC_WHEN_IDLE 消息时会进行 Looper.myQueue().addIdleHandler(mGcIdler)，而 mGcIdler 最后会触发 doGcIfNeeded 操作，在该方法中会判断上次 GC 与现在时间的差值，而这个值就是 MIN_TIME_BETWEEN_GCS = 5*1000。</p><p>查看 moveToRetained 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Synchronized</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>moveToRetained</span>(key: String) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//再次移除已被回收的对象对应的弱引用 Reference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  removeWeaklyReachableObjects()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> retainedRef = watchedObjects[key]
</span></span><span style=display:flex><span>  <span style=color:#75715e>//如果用这个 key 对应的 Reference 没有被移除，说明已经发生泄漏
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (retainedRef <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()
</span></span><span style=display:flex><span>    <span style=color:#75715e>//通知 listener
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    onObjectRetainedListeners.forEach { <span style=color:#66d9ef>it</span>.onObjectRetained() }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在经过 5s 后，再次移除被回收的对象对应的 Reference。然后再判断 watchedObjects 集合中是否是否仍然存在该 key 对应的 value，如果存在则认为该 value 对应的对象发生了泄露。随后记录下发生时间，并通知 listener 发生对象残留情况。</p><p>这里的 listener 就是 InternalLeakCanary 的 invoke 方法中设置的 InternalLeakCanary.this 对象，查看 InternalLeakCanary 的 onObjectRetained 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onObjectRetained</span>() = scheduleRetainedObjectCheck()
</span></span><span style=display:flex><span>继续跟进<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>scheduleRetainedObjectCheck</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>heapDumpTrigger.isInitialized) {
</span></span><span style=display:flex><span>    heapDumpTrigger.scheduleRetainedObjectCheck()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>继续追踪 HeapDumpTrigger 的 scheduleRetainedObjectCheck 方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>scheduleRetainedObjectCheck</span>(
</span></span><span style=display:flex><span>  delayMillis: Long = <span style=color:#ae81ff>0L</span>
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> checkCurrentlyScheduledAt = checkScheduledAt
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (checkCurrentlyScheduledAt &gt; <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis
</span></span><span style=display:flex><span>  <span style=color:#75715e>//将后面的流程 post 到后台线程执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  backgroundHandler.postDelayed({
</span></span><span style=display:flex><span>    checkScheduledAt = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    checkRetainedObjects()
</span></span><span style=display:flex><span>  }, delayMillis)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>查看 checkretainedObjects 方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>checkRetainedObjects</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> config = configProvider()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (iCanHasHeap <span style=color:#66d9ef>is</span> Nope) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//获取没有被回收对象的个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> retainedReferenceCount = objectWatcher.retainedObjectCount
</span></span><span style=display:flex><span>  <span style=color:#75715e>//如果没有被回收的对象个数大于 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (retainedReferenceCount &gt; <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//执行一次GC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    gcTrigger.runGc()
</span></span><span style=display:flex><span>    <span style=color:#75715e>//再次获取没有被回收对象的个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    retainedReferenceCount = objectWatcher.retainedObjectCount
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//检查没有被回收对象的个数，如果少于 5 个则返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> now = SystemClock.uptimeMillis()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis
</span></span><span style=display:flex><span>  <span style=color:#75715e>//WAIT_BETWEEN_HEAP_DUMPS_MILLIS 为 60_000L
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//即 60 秒内再次发现泄漏只会发出通知并返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) {
</span></span><span style=display:flex><span>    onRetainInstanceListener.onEvent(DumpHappenedRecently)
</span></span><span style=display:flex><span>    showRetainedCountNotification(
</span></span><span style=display:flex><span>      objectCount = retainedReferenceCount,
</span></span><span style=display:flex><span>      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    scheduleRetainedObjectCheck(
</span></span><span style=display:flex><span>      delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  dismissRetainedCountNotification()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> visibility = <span style=color:#66d9ef>if</span> (applicationVisible) <span style=color:#e6db74>&#34;visible&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;not visible&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//获取内存快照，即.hprof文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  dumpHeap(
</span></span><span style=display:flex><span>    retainedReferenceCount = retainedReferenceCount,
</span></span><span style=display:flex><span>    retry = <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    reason = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$retainedReferenceCount</span><span style=color:#e6db74> retained objects, app is </span><span style=color:#e6db74>$visibility</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=获取-dumpheap-文件>获取 dumpHeap 文件
<a class=anchor href=#%e8%8e%b7%e5%8f%96-dumpheap-%e6%96%87%e4%bb%b6>#</a></h2><p>继续查看：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>dumpHeap</span>(
</span></span><span style=display:flex><span>  retainedReferenceCount: Int,
</span></span><span style=display:flex><span>  retry: Boolean,
</span></span><span style=display:flex><span>  reason: String
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  saveResourceIdNamesToMemory()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()
</span></span><span style=display:flex><span>  KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
</span></span><span style=display:flex><span>  <span style=color:#75715e>//调用 AndroidHeapDumper 的 dumpHeap 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>when</span> (<span style=color:#66d9ef>val</span> heapDumpResult = heapDumper.dumpHeap()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>is</span> NoHeapDump <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (retry) {
</span></span><span style=display:flex><span>        SharkLog.d { <span style=color:#e6db74>&#34;Failed to dump heap, will retry in </span><span style=color:#e6db74>$WAIT</span><span style=color:#e6db74>_AFTER_DUMP_FAILED_MILLIS ms&#34;</span> }
</span></span><span style=display:flex><span>        scheduleRetainedObjectCheck(
</span></span><span style=display:flex><span>          delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        SharkLog.d { <span style=color:#e6db74>&#34;Failed to dump heap, will not automatically retry&#34;</span> }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      showRetainedCountNotification(
</span></span><span style=display:flex><span>        objectCount = retainedReferenceCount,
</span></span><span style=display:flex><span>        contentText = application.getString(
</span></span><span style=display:flex><span>          R.string.leak_canary_notification_retained_dump_failed
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>      )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>is</span> HeapDump <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>      lastDisplayedRetainedObjectCount = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>      lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()
</span></span><span style=display:flex><span>      <span style=color:#75715e>//清理 objectWatcher 中 heapDumpUptimeMillis 之前保存的键值对
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
</span></span><span style=display:flex><span>      <span style=color:#75715e>//分析 dump 文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      HeapAnalyzerService.runAnalysis(
</span></span><span style=display:flex><span>        context = application,
</span></span><span style=display:flex><span>        heapDumpFile = heapDumpResult.<span style=color:#66d9ef>file</span>,
</span></span><span style=display:flex><span>        heapDumpDurationMillis = heapDumpResult.durationMillis,
</span></span><span style=display:flex><span>        heapDumpReason = reason
</span></span><span style=display:flex><span>      )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Synchronized</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>clearObjectsWatchedBefore</span>(heapDumpUptimeMillis: Long) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> weakRefsToRemove =
</span></span><span style=display:flex><span>    watchedObjects.filter { <span style=color:#66d9ef>it</span>.value.watchUptimeMillis <span style=color:#f92672>&lt;=</span> heapDumpUptimeMillis }
</span></span><span style=display:flex><span>  weakRefsToRemove.values.forEach { <span style=color:#66d9ef>it</span>.clear() }
</span></span><span style=display:flex><span>  watchedObjects.keys.removeAll(weakRefsToRemove.keys)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=heapdump-文件解析>heapDump 文件解析
<a class=anchor href=#heapdump-%e6%96%87%e4%bb%b6%e8%a7%a3%e6%9e%90>#</a></h2><p>继续查看 HeapAnalyzerService 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>runAnalysis</span>(
</span></span><span style=display:flex><span>  context: Context,
</span></span><span style=display:flex><span>  heapDumpFile: File,
</span></span><span style=display:flex><span>  heapDumpDurationMillis: Long? = <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>  heapDumpReason: String = <span style=color:#e6db74>&#34;Unknown&#34;</span>
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> intent = Intent(context, HeapAnalyzerService<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java)
</span></span><span style=display:flex><span>  intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)
</span></span><span style=display:flex><span>  intent.putExtra(HEAPDUMP_REASON_EXTRA, heapDumpReason)
</span></span><span style=display:flex><span>  heapDumpDurationMillis<span style=color:#f92672>?.</span>let {
</span></span><span style=display:flex><span>    intent.putExtra(HEAPDUMP_DURATION_MILLIS_EXTRA, heapDumpDurationMillis)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//启动一个 Service，并将 heapDump 文件信息传入进去
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  startForegroundService(context, intent)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>startForegroundService</span>(
</span></span><span style=display:flex><span>  context: Context,
</span></span><span style=display:flex><span>  intent: Intent
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (SDK_INT <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>26</span>) {
</span></span><span style=display:flex><span>    context.startForegroundService(intent)
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Pre-O behavior.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    context.startService(intent)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>启动 HeapAnalyzerService 后：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onHandleIntentInForeground</span>(intent: Intent?) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (intent <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!in</span>tent.hasExtra(HEAPDUMP_FILE_EXTRA)) {
</span></span><span style=display:flex><span>    SharkLog.d { <span style=color:#e6db74>&#34;HeapAnalyzerService received a null or empty intent, ignoring.&#34;</span> }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Since we&#39;re running in the main process we should be careful not to impact it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) <span style=color:#66d9ef>as</span> File
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> heapDumpReason = intent.getStringExtra(HEAPDUMP_REASON_EXTRA)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> heapDumpDurationMillis = intent.getLongExtra(HEAPDUMP_DURATION_MILLIS_EXTRA, -<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> config = LeakCanary.config
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> heapAnalysis = <span style=color:#66d9ef>if</span> (heapDumpFile.exists()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 分析heapDump 文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    analyzeHeap(heapDumpFile, config)
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    missingFileFailure(heapDumpFile)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> fullHeapAnalysis = <span style=color:#66d9ef>when</span> (heapAnalysis) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>is</span> HeapAnalysisSuccess <span style=color:#f92672>-&gt;</span> heapAnalysis.copy(
</span></span><span style=display:flex><span>      dumpDurationMillis = heapDumpDurationMillis,
</span></span><span style=display:flex><span>      metadata = heapAnalysis.metadata + (<span style=color:#e6db74>&#34;Heap dump reason&#34;</span> to heapDumpReason)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>is</span> HeapAnalysisFailure <span style=color:#f92672>-&gt;</span> heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//将分析结果回调给 onHeapAnalyzedListener
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>analyzeHeap</span>(
</span></span><span style=display:flex><span>  heapDumpFile: File,
</span></span><span style=display:flex><span>  config: Config
</span></span><span style=display:flex><span>): HeapAnalysis {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> heapAnalyzer = HeapAnalyzer(<span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> proguardMappingReader = <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    ProguardMappingReader(assets.<span style=color:#66d9ef>open</span>(PROGUARD_MAPPING_FILE_NAME))
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (e: IOException) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> heapAnalyzer.analyze(
</span></span><span style=display:flex><span>    heapDumpFile = heapDumpFile,
</span></span><span style=display:flex><span>    leakingObjectFinder = config.leakingObjectFinder,
</span></span><span style=display:flex><span>    referenceMatchers = config.referenceMatchers,
</span></span><span style=display:flex><span>    computeRetainedHeapSize = config.computeRetainedHeapSize,
</span></span><span style=display:flex><span>    objectInspectors = config.objectInspectors,
</span></span><span style=display:flex><span>    metadataExtractor = config.metadataExtractor,
</span></span><span style=display:flex><span>    proguardMapping = proguardMappingReader<span style=color:#f92672>?.</span>readProguardMapping()
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>查看 heapAnalyzer.analyzeHeap 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>analyze</span>(
</span></span><span style=display:flex><span>  heapDumpFile: File,
</span></span><span style=display:flex><span>  leakingObjectFinder: LeakingObjectFinder,
</span></span><span style=display:flex><span>  referenceMatchers: List&lt;ReferenceMatcher&gt; = emptyList(),
</span></span><span style=display:flex><span>  computeRetainedHeapSize: Boolean = <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>  objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),
</span></span><span style=display:flex><span>  metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
</span></span><span style=display:flex><span>  proguardMapping: ProguardMapping? = <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>): HeapAnalysis {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> analysisStartNanoTime = System.nanoTime()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (!heapDumpFile.exists()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> exception = IllegalArgumentException(<span style=color:#e6db74>&#34;File does not exist: </span><span style=color:#e6db74>$heapDumpFile</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> HeapAnalysisFailure(
</span></span><span style=display:flex><span>      heapDumpFile = heapDumpFile,
</span></span><span style=display:flex><span>      createdAtTimeMillis = System.currentTimeMillis(),
</span></span><span style=display:flex><span>      analysisDurationMillis = since(analysisStartNanoTime),
</span></span><span style=display:flex><span>      exception = HeapAnalysisException(exception)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    listener.onAnalysisProgress(PARSING_HEAP_DUMP)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))
</span></span><span style=display:flex><span>    <span style=color:#75715e>//从文件中解析获取对象关系图结构 graph
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//并获取图中的所有 GC roots 根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sourceProvider.openHeapGraph(proguardMapping).use { graph <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>//创建 FindLeakInput 对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>val</span> helpers =
</span></span><span style=display:flex><span>        FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)
</span></span><span style=display:flex><span>       <span style=color:#75715e>//查找内存泄漏对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>val</span> result = helpers.analyzeGraph(
</span></span><span style=display:flex><span>        metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime
</span></span><span style=display:flex><span>      )
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> lruCacheStats = (graph <span style=color:#66d9ef>as</span> HprofHeapGraph).lruCacheStats()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> randomAccessStats =
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;RandomAccess[&#34;</span> +
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;bytes=</span><span style=color:#e6db74>${sourceProvider.randomAccessByteReads}</span><span style=color:#e6db74>,&#34;</span> +
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;reads=</span><span style=color:#e6db74>${sourceProvider.randomAccessReadCount}</span><span style=color:#e6db74>,&#34;</span> +
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;travel=</span><span style=color:#e6db74>${sourceProvider.randomAccessByteTravel}</span><span style=color:#e6db74>,&#34;</span> +
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;range=</span><span style=color:#e6db74>${sourceProvider.byteTravelRange}</span><span style=color:#e6db74>,&#34;</span> +
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;size=</span><span style=color:#e6db74>${heapDumpFile.length()}</span><span style=color:#e6db74>&#34;</span> +
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;]&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> stats = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$lruCacheStats</span><span style=color:#e6db74> </span><span style=color:#e6db74>$randomAccessStats</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>      result.copy(metadata = result.metadata + (<span style=color:#e6db74>&#34;Stats&#34;</span> to stats))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (exception: Throwable) {
</span></span><span style=display:flex><span>    HeapAnalysisFailure(
</span></span><span style=display:flex><span>      heapDumpFile = heapDumpFile,
</span></span><span style=display:flex><span>      createdAtTimeMillis = System.currentTimeMillis(),
</span></span><span style=display:flex><span>      analysisDurationMillis = since(analysisStartNanoTime),
</span></span><span style=display:flex><span>      exception = HeapAnalysisException(exception)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>FindLeakInput</span>.analyzeGraph(
</span></span><span style=display:flex><span>  metadataExtractor: MetadataExtractor,
</span></span><span style=display:flex><span>  leakingObjectFinder: LeakingObjectFinder,
</span></span><span style=display:flex><span>  heapDumpFile: File,
</span></span><span style=display:flex><span>  analysisStartNanoTime: Long
</span></span><span style=display:flex><span>): HeapAnalysisSuccess {
</span></span><span style=display:flex><span>  listener.onAnalysisProgress(EXTRACTING_METADATA)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> metadata = metadataExtractor.extractMetadata(graph)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//通过过滤 graph 中的 KeyedWeakReference 类型对象来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//找到对应的内存泄漏对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> retainedClearedWeakRefCount = KeyedWeakReferenceFinder.findKeyedWeakReferences(graph)
</span></span><span style=display:flex><span>    .filter { <span style=color:#66d9ef>it</span>.isRetained <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#66d9ef>it</span>.hasReferent }.count()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// This should rarely happens, as we generally remove all cleared weak refs right before a heap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// dump.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> metadataWithCount = <span style=color:#66d9ef>if</span> (retainedClearedWeakRefCount &gt; <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    metadata + (<span style=color:#e6db74>&#34;Count of retained yet cleared&#34;</span> to <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$retainedClearedWeakRefCount</span><span style=color:#e6db74> KeyedWeakReference instances&#34;</span>)
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    metadata
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//计算内存泄漏对象到 GC roots 的路径
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> <span style=color:#960050;background-color:#1e0010>(</span>applicationLeaks, libraryLeaks, unreachableObjects) = findLeaks(leakingObjectIds)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> HeapAnalysisSuccess(
</span></span><span style=display:flex><span>    heapDumpFile = heapDumpFile,
</span></span><span style=display:flex><span>    createdAtTimeMillis = System.currentTimeMillis(),
</span></span><span style=display:flex><span>    analysisDurationMillis = since(analysisStartNanoTime),
</span></span><span style=display:flex><span>    metadata = metadataWithCount,
</span></span><span style=display:flex><span>    applicationLeaks = applicationLeaks,
</span></span><span style=display:flex><span>    libraryLeaks = libraryLeaks,
</span></span><span style=display:flex><span>    unreachableObjects = unreachableObjects
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>FindLeakInput</span>.findLeaks(leakingObjectIds: Set&lt;Long&gt;): LeaksAndUnreachableObjects {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)
</span></span><span style=display:flex><span>  <span style=color:#75715e>//计算并获取目标对象到 GC roots 的最短路径
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> pathFindingResults =
</span></span><span style=display:flex><span>    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> unreachableObjects = findUnreachableObjects(pathFindingResults, leakingObjectIds)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> shortestPaths =
</span></span><span style=display:flex><span>    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> inspectedObjectsByPath = inspectObjects(shortestPaths)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> retainedSizes =
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pathFindingResults.dominatorTree <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      computeRetainedSizes(inspectedObjectsByPath, pathFindingResults.dominatorTree)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#960050;background-color:#1e0010>(</span>applicationLeaks, libraryLeaks) = buildLeakTraces(
</span></span><span style=display:flex><span>    shortestPaths, inspectedObjectsByPath, retainedSizes
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> LeaksAndUnreachableObjects(applicationLeaks, libraryLeaks, unreachableObjects)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=展示通知>展示通知
<a class=anchor href=#%e5%b1%95%e7%a4%ba%e9%80%9a%e7%9f%a5>#</a></h2><p>回到 HeapAnalyzerService 中，analyzeHeap 方法得到分析结果后，会将结果回调给 onHeapAnalyzedListener。</p><p>这里 onHeapAnalyzedListener 的唯一实现类为 DefaultOnHeapAnalyzedListener：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onHeapAnalyzed</span>(heapAnalysis: HeapAnalysis) {
</span></span><span style=display:flex><span>  SharkLog.d { <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\u200B\n</span><span style=color:#e6db74>${LeakTraceWrapper.wrap(heapAnalysis.toString(), 120)}</span><span style=color:#e6db74>&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> db = LeaksDbHelper(application).writableDatabase
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> id = HeapAnalysisTable.insert(db, heapAnalysis)
</span></span><span style=display:flex><span>  db.releaseReference()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#960050;background-color:#1e0010>(</span>contentTitle, screenToShow) = <span style=color:#66d9ef>when</span> (heapAnalysis) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>is</span> HeapAnalysisFailure <span style=color:#f92672>-&gt;</span> application.getString(
</span></span><span style=display:flex><span>      R.string.leak_canary_analysis_failed
</span></span><span style=display:flex><span>    ) to HeapAnalysisFailureScreen(id)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>is</span> HeapAnalysisSuccess <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> retainedObjectCount = heapAnalysis.allLeaks.sumBy { <span style=color:#66d9ef>it</span>.leakTraces.size }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>val</span> leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size
</span></span><span style=display:flex><span>      application.getString(
</span></span><span style=display:flex><span>        R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount
</span></span><span style=display:flex><span>      ) to HeapDumpScreen(id)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (InternalLeakCanary.formFactor <span style=color:#f92672>==</span> TV) {
</span></span><span style=display:flex><span>    showToast(heapAnalysis)
</span></span><span style=display:flex><span>    printIntentInfo()
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//展示通知
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    showNotification(screenToShow, contentTitle)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后将结果通过通知的方式展示出来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>showNotification</span>(
</span></span><span style=display:flex><span>  screenToShow: Screen,
</span></span><span style=display:flex><span>  contentTitle: String
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> pendingIntent = LeakActivity.createPendingIntent(
</span></span><span style=display:flex><span>    application, arrayListOf(HeapDumpsScreen(), screenToShow)
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> contentText = application.getString(R.string.leak_canary_notification_message)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Notifications.showNotification(
</span></span><span style=display:flex><span>    application, contentTitle, contentText, pendingIntent,
</span></span><span style=display:flex><span>    R.id.leak_canary_notification_analysis_result,
</span></span><span style=display:flex><span>    LEAKCANARY_MAX
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><p>总结下 LeakCanary 对于 Activity 内存泄漏分析过程：</p><ol><li>初始化 LeakCanary 需要的对象</li><li>注册监听 Activity 生命周期 onDestroy 事件</li><li>在 Activity 的 onDestroy 事件回调后，创建 KeyedWeakReference 对象，并关联 ReferenceQueue</li><li>延时 5 秒检查目标对象是否回收</li><li>未回收则开启服务，dump heap 获取内存快照 hprof 文件</li><li>解析 hprof 文件根据 KeyedWeakReference 类型过滤找到内存泄漏对象</li><li>计算对象到 GC roots 的最短路径，并合并所有最短路径为一棵树</li><li>输出分析结果，并根据分析结果通过通知的方式展示出来</li></ol><p><img src=https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/LeakCanary/clipboard_20230323_035231.png width=auto alt></p><p><img src=https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/LeakCanary/clipboard_20230323_035234.png width=auto alt></p><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://guanpj.github.io/amethyst/quartz/js/graph.cbd78cfa87df7d3e230d16fc24f06548.js></script></div></div><div id=contact_buttons><footer><p>Made with <a href=https://github.com/64bitpandas/amethyst>Amethyst</a>, © 2023 guanpj</p><ul><li><a href=https://guanpj.github.io/amethyst/>Home</a></li><li><a href=https://bencuan.me>Website</a></li><li><a href=https://blog.bencuan.me>Blog</a></li></ul></footer></div></article><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#reference-介绍>Reference 介绍</a></li><li><a href=#referencequeue-原理和使用示例>ReferenceQueue 原理和使用示例</a></li><li><a href=#leakcanary-基本使用>LeakCanary 基本使用</a><ul><li><a href=#20-之前>2.0 之前</a></li><li><a href=#20-开始>2.0 开始</a></li></ul></li><li><a href=#leakcanary-原理分析>LeakCanary 原理分析</a><ul><li><a href=#初始化>初始化</a></li><li><a href=#activity-回收监听>Activity 回收监听</a></li><li><a href=#获取-dumpheap-文件>获取 dumpHeap 文件</a></li><li><a href=#heapdump-文件解析>heapDump 文件解析</a></li><li><a href=#展示通知>展示通知</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></aside></main></body></html>