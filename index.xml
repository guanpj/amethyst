<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on</title><link>https://guanpj.github.io/amethyst/</link><description>Recent content in Home on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://guanpj.github.io/amethyst/2023-03-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/2023-03-15/</guid><description>弄完了同步，牛逼</description></item><item><title/><link>https://guanpj.github.io/amethyst/2023-03-16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/2023-03-16/</guid><description/></item><item><title/><link>https://guanpj.github.io/amethyst/2023-03-18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/2023-03-18/</guid><description>2023-03-18 # 今日开发工作 # 今日感想 #</description></item><item><title/><link>https://guanpj.github.io/amethyst/2023-03-19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/2023-03-19/</guid><description>今日开发工作 # 今日感想 #</description></item><item><title/><link>https://guanpj.github.io/amethyst/2023-03-20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/2023-03-20/</guid><description>今日开发工作 # 今日感想 # sadlfjsal
from windows
之类主页是[[Home]]</description></item><item><title/><link>https://guanpj.github.io/amethyst/Buttons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Buttons/</guid><description>name 灵光乍现 type command action QuickAdd: CMI color blue ^button-idea</description></item><item><title/><link>https://guanpj.github.io/amethyst/ControlPanel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/ControlPanel/</guid><description> [!example]+ 命令按钮 button-idea</description></item><item><title/><link>https://guanpj.github.io/amethyst/Linter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Linter/</guid><description>注意点: 要使用 vercel 或 github pages 或 cloudflare pages，不能用 netlify，因为 netlify 会自动将 url 小写，带来 bug。
核心 2 个点，命令参考 dg3 仓库的 deploy. yaml 文件：
- frontmatter 需要有 title，且 value 值加双引号。我用 linter 实现自动生成 title，但其不支持自动加双引号，目前我是自己用 sed 命令加上双引号，linter 作者说下个版本将支持 title 的 value 也加双引号。 目前已支持 [[wikilink]]，但依旧需要指定绝对引用路径，而我更习惯最短路径的引用方式，所以在构建时，我用 mv 命令将 md 文件批量移动至根目录，从而减少改文件链接的麻烦。 Date now: &amp;lt;% tp.file.title %&amp;gt; Date now with format: &amp;lt;% tp.date.now(&amp;ldquo;Do MMMM YYYY&amp;rdquo;) %&amp;gt;
Last week: &amp;lt;% tp.date.now(&amp;ldquo;dddd Do MMMM YYYY&amp;rdquo;, -7) %&amp;gt; Today: &amp;lt;% tp.</description></item><item><title/><link>https://guanpj.github.io/amethyst/MyDraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/MyDraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements # 塑料袋放进啊 ^etTuiyn6
撒地方 ^mLPqq627
%%
Drawing # { &amp;#34;type&amp;#34;: &amp;#34;excalidraw&amp;#34;, &amp;#34;version&amp;#34;: 2, &amp;#34;source&amp;#34;: &amp;#34;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.20&amp;#34;, &amp;#34;elements&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;aIIHmrl8D5QZxwcdvXN8I&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;rectangle&amp;#34;, &amp;#34;x&amp;#34;: -540, &amp;#34;y&amp;#34;: -257.25, &amp;#34;width&amp;#34;: 203, &amp;#34;height&amp;#34;: 114, &amp;#34;angle&amp;#34;: 0, &amp;#34;strokeColor&amp;#34;: &amp;#34;#000000&amp;#34;, &amp;#34;backgroundColor&amp;#34;: &amp;#34;transparent&amp;#34;, &amp;#34;fillStyle&amp;#34;: &amp;#34;hachure&amp;#34;, &amp;#34;strokeWidth&amp;#34;: 1, &amp;#34;strokeStyle&amp;#34;: &amp;#34;solid&amp;#34;, &amp;#34;roughness&amp;#34;: 1, &amp;#34;opacity&amp;#34;: 100, &amp;#34;groupIds&amp;#34;: [], &amp;#34;roundness&amp;#34;: { &amp;#34;type&amp;#34;: 3 }, &amp;#34;seed&amp;#34;: 626168919, &amp;#34;version&amp;#34;: 121, &amp;#34;versionNonce&amp;#34;: 1582943353, &amp;#34;isDeleted&amp;#34;: false, &amp;#34;boundElements&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;Z080p_bcAjknqx0PmQ1B5&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;arrow&amp;#34; }, { &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;etTuiyn6&amp;#34; } ], &amp;#34;updated&amp;#34;: 1679729051048, &amp;#34;link&amp;#34;: null, &amp;#34;locked&amp;#34;: false }, { &amp;#34;id&amp;#34;: &amp;#34;etTuiyn6&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;, &amp;#34;x&amp;#34;: -535, &amp;#34;y&amp;#34;: -212.</description></item><item><title/><link>https://guanpj.github.io/amethyst/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88/</guid><description>阿斯蒂芬
line1: &amp;lt;% tp.file.cursor(1) %&amp;gt; line2: &amp;lt;% tp.file.cursor(2) %&amp;gt;</description></item><item><title/><link>https://guanpj.github.io/amethyst/%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description/></item><item><title/><link>https://guanpj.github.io/amethyst/%E5%A7%94%E6%89%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%A7%94%E6%89%98/</guid><description>https://juejin.cn/post/7043843490366619685</description></item><item><title/><link>https://guanpj.github.io/amethyst/%E5%BC%95%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%BC%95%E7%94%A8/</guid><description>#include &amp;lt;iostream&amp;gt;using namespace std; // 函数声明 void swap(int&amp;amp; x, int&amp;amp; y); void swap1(int* x, int* y); void swap2(int x, int y); void swap3(int* x, int* y); int main () { // 局部变量声明 int a = 100; int b = 200; cout &amp;lt;&amp;lt; &amp;#34;交换前，&amp;amp;a 的值：&amp;#34; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换前，&amp;amp;b 的值：&amp;#34; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换前，a 的值：&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换前，b 的值：&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; /* 调用函数来交换值 */ //swap(a, b); //swap1(&amp;amp;a, &amp;amp;b); //swap2(a, b); swap3(&amp;amp;a, &amp;amp;b); cout &amp;lt;&amp;lt; &amp;#34;交换后，a 的值：&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换后，b 的值：&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换后，&amp;amp;a 的值：&amp;#34; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换后，&amp;amp;b 的值：&amp;#34; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; endl; return 0; } // 函数定义 void swap(int&amp;amp; x, int&amp;amp; y) { cout &amp;lt;&amp;lt; &amp;#34;swap&amp;#34; &amp;lt;&amp;lt; endl; int temp; temp = x; x = y; y = temp; } void swap1(int* x, int* y) { cout &amp;lt;&amp;lt; &amp;#34;swap1&amp;#34; &amp;lt;&amp;lt; endl; int* temp; temp = x; x = y; y = temp; } void swap2(int x, int y) { cout &amp;lt;&amp;lt; &amp;#34;swap2&amp;#34; &amp;lt;&amp;lt; endl; int temp; temp = x; x = y; y = temp; } void swap3(int* x, int* y) { cout &amp;lt;&amp;lt; &amp;#34;swap3&amp;#34; &amp;lt;&amp;lt; endl; int temp; temp = *x; *x = *y; *y = temp; }</description></item><item><title/><link>https://guanpj.github.io/amethyst/%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/</guid><description>fun main() { &amp;#34;a&amp;#34;.aaa { println(this) } &amp;#34;b&amp;#34;.bbb { println(this) } &amp;#34;c&amp;#34;.ccc { println(it) } } fun &amp;lt;T&amp;gt; T.aaa(block: T.() -&amp;gt; Unit) { block(this) } fun &amp;lt;T&amp;gt; T.bbb(block: T.() -&amp;gt; Unit) { this.block() } fun &amp;lt;T&amp;gt; T.ccc(block: (T) -&amp;gt; Unit) { block(this) }</description></item><item><title/><link>https://guanpj.github.io/amethyst/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/</guid><description/></item><item><title/><link>https://guanpj.github.io/amethyst/%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E6%8C%87%E9%92%88/</guid><description>#include &amp;lt;iostream&amp;gt; using namespace std; int main () { int var; int *ptr; int **pptr; int ***ppptr; var = 3000; // 获取 var 的地址 ptr = &amp;amp;var; // 使用运算符 &amp;amp; 获取 ptr 的地址 pptr = &amp;amp;ptr; ppptr = &amp;amp;pptr; cout &amp;lt;&amp;lt; &amp;#34;var 值为 :&amp;#34; &amp;lt;&amp;lt; var &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;ptr 值为:&amp;#34; &amp;lt;&amp;lt; ptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;pptr 值为:&amp;#34; &amp;lt;&amp;lt; pptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;ppptr 值为:&amp;#34; &amp;lt;&amp;lt; ppptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-------------------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;*&amp;amp;var 值为:&amp;#34; &amp;lt;&amp;lt; *&amp;amp;*&amp;amp;var &amp;lt;&amp;lt; endl; //cout &amp;lt;&amp;lt; &amp;#34;pptr 值为:&amp;#34; &amp;lt;&amp;lt; pptr &amp;lt;&amp;lt; endl; //cout &amp;lt;&amp;lt; &amp;#34;ppptr 值为:&amp;#34; &amp;lt;&amp;lt; ppptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-------------------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;var 值为 :&amp;#34; &amp;lt;&amp;lt; var &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;*ptr 值为:&amp;#34; &amp;lt;&amp;lt; *ptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;**pptr 值为:&amp;#34; &amp;lt;&amp;lt; **pptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;***ppptr 值为:&amp;#34; &amp;lt;&amp;lt; ***ppptr &amp;lt;&amp;lt; endl; return 0; }</description></item><item><title/><link>https://guanpj.github.io/amethyst/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2/</guid><description>filename = &amp;#39;user.txt&amp;#39; with open(filename) as f: lines = f.readlines() newData = &amp;#34;&amp;#34; for line in lines: lineArr = line.rstrip().split(&amp;#39; &amp;#39;) if len(lineArr) == 2: idNum = lineArr[1] sex = &amp;#34;女&amp;#34; if int(idNum[len(idNum) - 2], 10) % 2 == 0 else &amp;#34;男&amp;#34; newData += &amp;#39;{}{}{}\n&amp;#39;.format(lineArr[0], idNum, sex) with open(filename, &amp;#34;w&amp;#34;) as f: f.write(newData)</description></item><item><title/><link>https://guanpj.github.io/amethyst/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8/</guid><description>#类定义 class people: #定义基本属性 name = &amp;#39;&amp;#39; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&amp;#34;%s说: 我 %d岁。&amp;#34; %(self.name,self.age)) # 实例化类 p = people(&amp;#39;runoob&amp;#39;,10,30) p.speak()</description></item><item><title/><link>https://guanpj.github.io/amethyst/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D/</guid><description>import os,re def traversal_files1(path): for root, dirs, files in os.walk(path, topdown=False): f = os.path.join(root, name) for name in files: print(f) for name in dirs: print(f) def traversal_files(root): for lists in os.listdir(root): f = os.path.join(root, lists) if os.path.isdir(f): #字符串查找 if f.find(&amp;#39;(更多IT教程-微信634631778)&amp;#39;) != -1: print(f) #字符串替换 newname = f.replace(&amp;#39;(更多IT教程-微信634631778)&amp;#39;, &amp;#39;&amp;#39;) print(newname) #文件重命名 os.rename(f, newname) traversal_files(newname) else: traversal_files(f) else: #正则表达式匹配 pattern = re.</description></item><item><title>2023-03-24</title><link>https://guanpj.github.io/amethyst/2023-03-24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/2023-03-24/</guid><description/></item><item><title>&lt;% tp.file.title %></title><link>https://guanpj.github.io/amethyst/%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/</guid><description/></item><item><title>&lt;% tp.file.title %></title><link>https://guanpj.github.io/amethyst/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/</guid><description/></item><item><title>About Atlas</title><link>https://guanpj.github.io/amethyst/About-Atlas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/About-Atlas/</guid><description>Atlas意思是地图集。
单个案例或项目的MOC，考虑直接放在对应文件夹里面，相当于起到一个个文件夹的readme和导览的作用。这里专门放这些MOC的MOC。
围绕本库和obsidian的使用教程、方法和细节，也放到这里，就像是地图的指南针。</description></item><item><title>About Extras</title><link>https://guanpj.github.io/amethyst/About-Extras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/About-Extras/</guid><description/></item><item><title>ADB 命令</title><link>https://guanpj.github.io/amethyst/ADB-%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/ADB-%E5%91%BD%E4%BB%A4/</guid><description>shell # adb shell 常用的命令有 ：
am（activity manager） 可执行 启动 activity，service，broadcast，杀死进程等操作。
pm（package manager） 可以执行 安装/卸载 应用，输出 apk 路径等操作。
dpm（device policy manager） 可以执行设备管理器相关命令，激活设备管理员，设置设备管理器 owner 等。
screencap （截屏） 使用该命令可以快速截屏并将图片保存至指定路径，截屏过程用户无感知。
ps # adb shell ps &amp;ndash;help
查看帮助
常用参数 # -p 后面加 进程 id ，可以显示进程为指定 id 的信息 adb shell ps -p 1 USER PID PPID VSZ RSS WCHAN ADDR S NAME root 1 0 10782796 4384 0 0 S init -P 后面加 父进程 id，可以显示父进程为指定 id 的信息 adb shell ps -P 1 USER PID PPID VSZ RSS WCHAN ADDR S NAME root 133 1 10761096 2540 0 0 S init root 285 1 13495412 127540 0 0 S zygote64 root 286 1 1840080 116252 0 0 S zygote -u 后面加 user 名，可以显示指定 user 的信息 adb shell ps -u system USER PID PPID VSZ RSS WCHAN ADDR S NAME system 164 1 10759476 4296 0 0 S servicemanager system 551 285 13891404 262940 0 0 S system_server // 省略.</description></item><item><title>ADB 命令</title><link>https://guanpj.github.io/amethyst/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>代理模式是软件开发中常见的设计模式，它的目的是让调用者不用持有具体操作者的引用，而是通过代理者去对具体操作者执行具体的操作。本文通过使用静态代理和动态代理分别实现代理模式，来对比和分析两者的实现原理。
静态代理的实现 # 代理接口：
public interface Person {  String doSomething(int i); } 目标对象：
public class Worker implements Person {  @Override  public String doSomething(int i) {  System.out.println(&amp;#34;I&amp;#39;m doing something by param: &amp;#34; + i);  } } 代理对象：
public class PersonProxy implements Person {  private Worker worker = null;  @Override  public String doSomething(int i) {  beforeDoSomething();  if(worker == null) {  worker = new Worker();  }  Stirng result = worker.</description></item><item><title>Android 对容器类的优化</title><link>https://guanpj.github.io/amethyst/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96/</guid><description>在之前 HashMap 的源码解析的文章 中可知，HashMap 的一级存储结构是一个初始容量为 16 的数组， 所以当我们创建出一个 HashMap 对象时，即使里面没有任何元素，也要分别一块内存空间给它。而且，在不断的向 HashMap 里 put 数据的过程中，当数据量达到阈值（容量 * 加载因子，加载因子默认为 0.75）时，将会触发 HashMap 扩容流程，扩大后新的容量一定是原来的 2 倍。
假如我们有几十万、几百万条数据，那么 HashMap 要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做 hash 运算，这将对我们的内存空间造成很大消耗和浪费，再加上 HashMap 获取数据是通过遍历 Entry[] 数组来得到对应的元素，在数据量很大时候会比较慢。
所以对于运行在移动设备上的 Android 系统来说，HashMap 的使用会造成比较大的负担。因此在
android.util 包中，提供了几个容器类，在某些情况下可以取代 HashMap 以提升性能。
SparseArray # 相比于比 HashMap ，SparseArray 更省内存，并且在某些条件下性能更好，主要是因为它避免了对 key 的自动装箱（int 转为 Integer 类型）。与普通的对象数组不同，它的索引可以包含间隙，因此得名 SparseArray（稀疏数组）。它的内部采用数组来存储 key，并且通过二分查找定位到目标 key，因此在数据量达到数百个时，效率将会降低至少 50% 之于 HashMap。
为了提高性能，在删除某项数据时，SparseArray 并不会马上删除 value 中的内容并且压缩整理 key 数组，而是会把将要删除的数据标记成 DELETE，后续可以重新用于相同 key 值的数据或者在 gc 操作的时候进行删除。SparseArray 在进行扩容前或者调用 size、indexOfKey 等方法时必须进行 gc 操作。</description></item><item><title>CAS 和 AQS 原理</title><link>https://guanpj.github.io/amethyst/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</guid><description>CAS # 介绍 # CAS 英文全称是 Compare-And-Swap，中文叫做“比较并交换”，它是一种思想、一种算法。
在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“比较并交换”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。
CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。CAS 最核心的思路就是，仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。
使用及原理 # ConcurrentHashMap # 截取 ConcurrentHashMap 部分 putVal 方法的代码，如下所示：
final V putVal(K key, V value, boolean onlyIfAbsent) {  if (key == null || value == null) throw new NullPointerException();  int hash = spread(key.hashCode());  int binCount = 0;  for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {  Node&amp;lt;K,V&amp;gt; f; int n, i, fh;  if (tab == null || (n = tab.</description></item><item><title>EventBus 使用及源码解析</title><link>https://guanpj.github.io/amethyst/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>使用 # 首先引入依赖 apply plugin: &amp;#39;kotlin-kapt&amp;#39; dependencies { implementation &amp;#39;org.greenrobot:eventbus:3.2.0&amp;#39; kapt &amp;#39;org.greenrobot:eventbus-annotation-processor:3.2.0&amp;#39; } kapt { arguments { arg(&amp;#39;eventBusIndex&amp;#39;, &amp;#39;com.me.guanpj.myapplication.MyEventBusIndex&amp;#39;) } } 从在 3.0 版本开始，EventBus 提供了一个 EventBusAnnotationProcessor 注解处理器来在编译期通过读取 @Subscribe 注解，并解析和处理其中所包含的信息，然后生成 Java 类索引来保存订阅者中所有的事件响应函数，这样就比在运行时使用反射来获得订阅者中所有事件响应函数的速度要快。
以下是来自官方对 EventBus 各个版本性能的对比图，可以看到，EventBus 3.x 如果没有使用索引的话性能相较于之前的版本是倒退的。使用索引能让 EventBus 的性能大大增加。
添加混淆规则： -keepattributes *Annotation* -keepclassmembers class * { @org.greenrobot.eventbus.Subscribe &amp;lt;methods&amp;gt;; } -keep enum org.greenrobot.eventbus.ThreadMode { *; } # And if you use AsyncExecutor: -keepclassmembers class * extends org.</description></item><item><title>Glide 加载流程和缓存原理分析</title><link>https://guanpj.github.io/amethyst/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>加载流程 # Glide 最普通的用法如下：
Glide.with(this).load(url).into(textView);
以首次加载 url 指向的资源到 textView 对象为例，由于代码实在太过冗长，下面用流程图的方式表示各个环节的执行顺序。
with # with 流程的主要职责：
创建 RequestManager 对象 初始化各式各样的配置信息（缓存、请求线程池、图片大小和格式等等）以及 Glide 单例对象。 将 Glide 请求和 application/Activity/SupportFragment/Fragment 的生命周期绑定在一起，从而实现自动执行请求，暂停操作。 public class Glide implements ComponentCallbacks2 { ... @NonNull public static RequestManager with(@NonNull Context context) { return getRetriever(context).get(context); } @NonNull public static RequestManager with(@NonNull Activity activity) { return getRetriever(activity).get(activity); } @NonNull public static RequestManager with(@NonNull FragmentActivity activity) { return getRetriever(activity).</description></item><item><title>Glide 基本使用</title><link>https://guanpj.github.io/amethyst/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>准备 # 添加依赖 # implementation &amp;#39;com.github.bumptech.glide:glide:4.12.0&amp;#39; annotationProcessor &amp;#39;com.github.bumptech.glide:compiler:4.12.0&amp;#39; 添加网路权限 # &amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; 定义控件 # &amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;Button android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;load&amp;#34; app:layout_constraintLeft_toLeftOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; android:onClick=&amp;#34;load&amp;#34;/&amp;gt; &amp;lt;ImageView android:id=&amp;#34;@+id/image&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:src=&amp;#34;@mipmap/ic_launcher&amp;#34; app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34; app:layout_constraintLeft_toLeftOf=&amp;#34;parent&amp;#34; app:layout_constraintRight_toRightOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 加载图片 # 添加按钮监听，使用 Glide 加载网路图片：</description></item><item><title>Glide 高级用法</title><link>https://guanpj.github.io/amethyst/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid><description>回调与监听 # Target # 我们都知道，使用 Glide 在界面上加载并展示一张图片只需要一行代码：
Glide.with(this).load(url).into(imageView); 将 ImageView 的实例传入到 into() 方法当中，Glide 将图片加载完成之后，图片就能显示到 ImageView 上了。这是怎么实现的呢？来看一下 into() 方法的源码：
@NonNull public ViewTarget&amp;lt;ImageView, TranscodeType&amp;gt; into(@NonNull ImageView view) { Util.assertMainThread(); Preconditions.checkNotNull(view); BaseRequestOptions&amp;lt;?&amp;gt; requestOptions = this; if (!requestOptions.isTransformationSet() &amp;amp;&amp;amp; requestOptions.isTransformationAllowed() &amp;amp;&amp;amp; view.getScaleType() != null) { // Clone in this method so that if we use this RequestBuilder to load into a View and then // into a different target, we don&amp;#39;t retain the transformation applied based on the previous // View&amp;#39;s scale type.</description></item><item><title>HashMap 源码解析</title><link>https://guanpj.github.io/amethyst/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>前言 # HashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。
在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。
成员变量 # HashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：
public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;  implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable {  // 初始容量 16  static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16  // 最大容量，该数组最大值为2^31一次方。  static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;  // 默认的加载因子，如果构造的时候不传则为 0.</description></item><item><title>HTTP 基础</title><link>https://guanpj.github.io/amethyst/HTTP-%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/HTTP-%E5%9F%BA%E7%A1%80/</guid><description>什么是 HTTP ？ # Hypertext Transfer Protocol，超文本传输协议，和 HTML (Hypertext Markup Language 超文本标记语言) 一起诞生，用于在网络上请求和传输 HTML 内容。
超文本，即「扩展型文本」，指的是 HTML 中可以有链向别的文本的链接 (hyperlink)。
HTTP 报文格式 # 请求报文格式：
响应报文格式：
Request Method 请求方法 # GET # 用于获取资源 对服务器数据不进行修改 不发送 Body GET /users/1 HTTP/1.1 Host: api.github.com 对应 Retrofit 的代码：
@GET(&amp;#34;/users/{id}&amp;#34;) Call&amp;lt;User&amp;gt; getUser(@Path(&amp;#34;id&amp;#34;) String id, @Query(&amp;#34;gender&amp;#34;) String gender); POST # 用于增加或修改资源 发送给服务器的内容写在 Body 里面 POST /users HTTP/1.</description></item><item><title>Index for Atlases</title><link>https://guanpj.github.io/amethyst/Index-for-Atlases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Index-for-Atlases/</guid><description>// 获取当前文件所在的文件夹 const currentFolder = dv.current().file.folder // 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息 const groups = dv.pages(`&amp;#34;${currentFolder}&amp;#34;`).groupBy(p =&amp;gt; p.file.folder) for (let group of groups) { dv.header(4, group.key); dv.table([&amp;#34;Name&amp;#34;,&amp;#34;标签&amp;#34;,&amp;#34;入链&amp;#34;, &amp;#34;创建日期&amp;#34;, &amp;#34;修改日期&amp;#34;], group.rows .sort(k =&amp;gt; k.file.name, &amp;#39;asc&amp;#39;) .map(k =&amp;gt; [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday])) }</description></item><item><title>Index for Extras</title><link>https://guanpj.github.io/amethyst/Index-for-Extras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Index-for-Extras/</guid><description>// 获取当前文件所在的文件夹 const currentFolder = dv.current().file.folder // 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息 const groups = dv.pages(`&amp;#34;${currentFolder}&amp;#34;`).groupBy(p =&amp;gt; p.file.folder) for (let group of groups) { dv.header(4, group.key); dv.table([&amp;#34;Name&amp;#34;,&amp;#34;标签&amp;#34;,&amp;#34;入链&amp;#34;, &amp;#34;创建日期&amp;#34;, &amp;#34;修改日期&amp;#34;], group.rows .sort(k =&amp;gt; k.file.name, &amp;#39;asc&amp;#39;) .map(k =&amp;gt; [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday])) }</description></item><item><title>IO</title><link>https://guanpj.github.io/amethyst/IO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/IO/</guid><description/></item><item><title>Java 内存模型</title><link>https://guanpj.github.io/amethyst/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>JMM 是什么？ # JMM 是和多线程相关的一组规范，它 定义了 JVM 在计算机内存中的工作方式，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。这样，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的，从而保证了“一次编译，处处运行”。
因此，JMM 与处理器、缓存、并发、编译器有关。它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。
比如关键字 synchronized，JVM 就会在 JMM 的规则下，“翻译”出合适的指令，包括限制指令之间的顺序，以便在即使发生了重排序的情况下，也能保证必要的“可见性”。这样一来，不同的 JVM 对于相同的代码的执行结果就变得可预期了，Java 程序员就只需要用同步工具和关键字就可以开发出正确的并发程序了。
JMM 抽象结构 # Java 作为高级语言，他向开发者屏蔽了多层缓存等底层细节，用 JMM 定义了一套读写数据的规范。Java 线程之间的通信由 JMM 控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：
线程之间的共享变量存储在主内存中； 每个线程只能够直接接触到本地内存，无法直接操作主内存； 每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。 本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。
内存间交互操作 # Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。
read：把一个变量的值从主内存传输到工作内存中 load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中 use：把工作内存中一个变量的值传递给执行引擎 assign：把一个从执行引擎接收到的值赋给工作内存的变量 store：把工作内存的一个变量的值传送到主内存中 write：在 store 之后执行，把 store 得到的值放入主内存的变量中 lock：作用于主内存的变量 unlock JMM 三大特性 # 原子性 # 如果一个或者一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半就终止的情况，则认为此操作具有原子性。</description></item><item><title>JVM 中的对象和垃圾回收</title><link>https://guanpj.github.io/amethyst/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>虚拟机中的对象 # 了解了 JVM 运行时数据区域之后，大致明白了 JVM 内存模型的概况，对内存中的存放内容也有了初步了解。更进一步地，如果要了解内存中的数据的创建过程、在内存中如何布局、以及访问方式等，就必须要把范围限定到具体的虚拟机类型和集中在某一个内存区域上才有意义。下面以最常用的 HotSpot 虚拟机和最常用的内存区域 Java 堆为例，深入探索对象分配、布局和访问过程。
对象的创建 # 虚拟机遇到一条 new 指令时，首先检查是否被类加载器加载，如果没有，则必须先执行相应的类加载过程。类加载就是把 class 加载到 JVM 的运行时数据区的过程。
1、检查加载 # 首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。
2、分配内存 # 如果上一步检查加载成功，接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
分配内存主要有两种方式
指针碰撞 # 如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
空闲列表 # 如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
如果是 Serial、ParNew 等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞的方式，既简单又高效。
如果是使用 CMS 这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。
内存分配的并发安全问题 # 除如何划分可用空间之外，还有另外一个需要考虑的问题是：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。
解决方案有以下两种：
CAS 机制
对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。虽然这种方式解决了并发问题，但是我们不难发现，这种方式增加了复杂度，降低了内存的分配的功效性。</description></item><item><title>JVM 内存区域</title><link>https://guanpj.github.io/amethyst/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid><description>简介 # 什么是 JVM？ # Java 虚拟机（Java Virtual Machine，简称 JVM），它能识别 .class 后缀的字节码文件（Java bytecode），并且能够解析它的指令，最终调用操作系统上的函数以完成指定操作。
为什么需要 JVM？ # Java 程序使用 javac 编译成 .class 文件之后，还需要使用 Java 命令去主动执行它，操作系统并不认识这些 .class 文件，JVM 则充当了翻译官的角色。JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。
从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文件，就可以运行在诸如 Linux、Windows、MacOS 等平台上了。
JVM 解释的是类似于汇编语言的字节码，需要一个抽象的运行时环境。同时，这个虚拟环境也需要解决字节码加载、自动垃圾回收、并发等一系列问题。JVM 其实是一个规范，定义了 .class 文件的结构、加载机制、数据存储、运行时栈等诸多内容，最常用的 JVM 实现就是 Hotspot。
一个 Java 程序，首先经过 javac 编译成 .class 文件，然后 JVM 将其加载到 元数据 区，执行引擎将会通过 混合模式 执行这些字节码。执行时，会翻译成操作系统相关的函数。JVM 作为 .class 文件的黑盒存在，输入字节码，调用操作系统函数。 JVM、JRE 和 JDK 三者关系 # JVM 只是一个翻译官，它负责把字节码翻译成机器码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到 JRE。</description></item><item><title>JVM 字节码指令简介</title><link>https://guanpj.github.io/amethyst/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</guid><description>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）构成。
在 Java 虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。比如， iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。
编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的对 int 类型作为运算类型来进行的。
加载和存储指令 # 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。这些指令如下：
将一个局部变量加载到操作栈:iload、iload_、lload、lload_、fload、fload_、dload、dload_、aload、aload_ 将一个数值从操作数栈存储到局部变量表:istore、istore_、lstore、lstore_、fstore、fstore_、dstore、dstore_、astore、astore_ 将一个常量加载到操作数栈:bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_、lconst_、fconst_、dconst_ 扩充局部变量表的访问索引的指令:wide 运算指令 # 算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
加法指令:iadd、ladd、fadd、dadd 减法指令:isub、lsub、fsub、dsub 乘法指令:imul、lmul、fmul、dmul 除法指令:idiv、ldiv、fdiv、ddiv 求余指令:irem、lrem、frem、drem 取反指令:ineg、lneg、fneg、dneg 位移指令:ishl、ishr、iushr、lshl、lshr、lushr 按位或指令:ior、lor ·按位与指令:iand、land 按位异或指令:ixor、lxor ·局部变量自增指令:iinc 比较指令:dcmp g、dcmp l、fcmp g、fcmp l、lcmp 类型转换指令 # 类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码的显示类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</description></item><item><title>JVM 字节码结构分析</title><link>https://guanpj.github.io/amethyst/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid><description>概述 # 提到字节码，首先想到的就是 Java，Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。
​其实不止是 Java，其他很多编程语言如 Scala、Kotlin 和 Groovy 等都是运行在 JVM 的语言，因此它们对应的编译器也能够生成 .class 字节码。
源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。而字节码命令所能提供的语义描述能力是要明显强于 Java 本身的，所以有其他一些同样基于 JVM 的语言能提供许多 Java 所不支持的语言特性。
在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个 .java 文件从编译到运行的示例如下。
JVM 的指令由一个字节长度的操作码（opcode）和紧随其后的可选的操作数（operand）构成。“字节码”这个名字的由来也是因为操作码的长度用一个字节表示。
&amp;lt;opcode&amp;gt; [&amp;lt;operand1&amp;gt;, &amp;lt;operand2&amp;gt;]
比如将整型常量 100 压栈到栈顶的指令是 “bipush 100”，其中 bipush 就是操作码，100 就是操作数。
因为操作码长度只有 1 个字节长度，这使得编译后的字节码文件非常小巧紧凑，但同时也直接限制了整个 JVM 操作码指令集的数量最多只能有 256 个，目前已经使用了 200+。
大部分字节码指令都包含了所要操作的类型信息。比如 “ireturn” 用于返回一个 int 类型的数据，“dreturn” 用于返回一个 double 类型的的数据，“freturn” 指令用于返回一个 float 类型的数据，这种方式也使得字节码实际的指令类型远小于 200 个。</description></item><item><title>JVM 类加载机制</title><link>https://guanpj.github.io/amethyst/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid><description>概述 # JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 Java 类型，这个过程被称作 JVM 的类加载机制。
与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
类加载的时机 # 一个类型从被加载到虚拟机内存中开始到卸载位置，整个生命周期会经历如下七个阶段，其中验证、准备、解析三个部分统称为连接。 上图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段后再开始，这是为了支持 Java 语言的运行时半丁特性（也被称为动态绑定或者晚期绑定）。
主动引用 # 关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java 虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java 虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证和准备阶段自然需要在此之前开始）：
遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这四条指令的场景是：
使用 new 关键字实例化对象的时候。 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。 调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</description></item><item><title>LeakCanary 使用及源码解析</title><link>https://guanpj.github.io/amethyst/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>Reference 介绍 # Reference 即是我们平时所说的“引用”，与之对应的是一个泛型抽象类。四种引用类型：SoftReference(软引用)、WeakReference(弱引用)、PhantomReference（虚引用）都继承自 Reference。它的声明如下：
public abstract class Reference&amp;lt;T&amp;gt; { //引用对象 volatile T referent; //保存即将被回收的Reference对象 final ReferenceQueue&amp;lt;? super T&amp;gt; queue; //在Enqueued状态下即引用加入队列时，指向下一个待处理Reference对象,默认为null Reference queueNext; //在Pending状态下，待入列引用，默认为null Reference&amp;lt;?&amp;gt; pendingNext; ... } Reference 有四种状态：Active、Pending、Enqueued、Inactive，默认为 Active 状态。
ReferenceQueue 则是一个单向链表实现的队列数据结构，存储的是 Reference 对象。包含了入列 enqueue、出列 poll 和移除 remove 操作。
ReferenceQueue 原理和使用示例 # Reference 配合 ReferenceQueue 可以实现对象回收监听，使用方法如下：
//创建一个引用队列 ReferenceQueue queue = new ReferenceQueue(); //创建对象 Object object = new Object(); //创建 object 对象的弱引用，并关联引用队列 queue WeakReference reference = new WeakReference(object, queue); System.</description></item><item><title>MyIdeas</title><link>https://guanpj.github.io/amethyst/MyIdeas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/MyIdeas/</guid><description> sldfj</description></item><item><title>OkHttp 使用及源码分析</title><link>https://guanpj.github.io/amethyst/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>https://juejin.cn/post/6881436122950402056
请求流程 # 同步请求 # MainActivity.kt
val user = &amp;#34;guanpj&amp;#34; val client = OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .writeTimeout(30, TimeUnit.SECONDS) .readTimeout(30, TimeUnit.SECONDS) .proxy(Proxy.NO_PROXY) .addInterceptor(HttpLoggingInterceptor { message -&amp;gt; if (BuildConfig.DEBUG) { Log.i(&amp;#34;OkHttp&amp;#34;, message) } }) .build() val request: Request = Request.Builder() .url(&amp;#34;https://api.github.com/users/$user/repos&amp;#34;) .build() val response = client.newCall(request).execute() println(&amp;#34;Response status code: ${response.code}&amp;#34;) OkHttpClient.kt
/** Prepares the [request] to be executed at some point in the future.</description></item><item><title>Retrofit 使用及源码分析</title><link>https://guanpj.github.io/amethyst/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>使用 # 导入依赖。 implementation &amp;#34;com.squareup.okhttp3:okhttp:4.9.0&amp;#34; implementation &amp;#34;com.squareup.okhttp3:logging-interceptor:4.9.0&amp;#34; implementation &amp;#34;com.squareup.retrofit2:retrofit:2.9.0&amp;#34; implementation &amp;#34;com.squareup.retrofit2:converter-gson:2.9.0&amp;#34; implementation &amp;#34;com.squareup.retrofit2:adapter-rxjava3:2.9.0&amp;#34; implementation &amp;#34;io.reactivex.rxjava3:rxjava:3.0.0&amp;#34; implementation &amp;#34;io.reactivex.rxjava3:rxandroid:3.0.0&amp;#34; 创建一个 interface 作为 WebService 的请求集合，在里面用注解写入需要配置的请求方法。 interface GitHubService { @GET(&amp;#34;users/{user}/repos&amp;#34;) fun listRepos(@Path(&amp;#34;user&amp;#34;) user: String?): Call&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; @GET(&amp;#34;users/{user}/repos&amp;#34;) fun listReposRx(@Path(&amp;#34;user&amp;#34;) user: String?): Observable&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; @GET(&amp;#34;users/{user}/repos&amp;#34;) fun listReposCompletable(@Path(&amp;#34;user&amp;#34;) user: String?): CompletableFuture&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; @GET(&amp;#34;users/{user}/repos&amp;#34;) suspend fun listReposSuspend(@Path(&amp;#34;user&amp;#34;) user: String?): List&amp;lt;Repo&amp;gt; @GET(&amp;#34;users/{user}/repos&amp;#34;) fun listReposOptional(@Path(&amp;#34;user&amp;#34;) user: String?</description></item><item><title>RxJava 使用及源码分析</title><link>https://guanpj.github.io/amethyst/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>https://juejin.cn/post/6881436122950402056
介绍 # Rx 是 ReactiveX 的简写，后者是 Reactive Extensions 的缩写，Rx 是一种编程模型，用于方便处理异步数据流。
RxJava 是响应式编程（Reactive Extensions）在 Java VM 上的实现，是一个在 Java VM 上使用可观察序列来组成异步的、基于事件的程序库。
它扩展了观察者模式以支持数据/事件序列，并添加了运算符，允许以声明方式将序列组合在一起，同时抽象出对低级线程、同步、线程安全和并发数据结构等事物的关注。
RxJava 是一个 基于事件流、实现异步操作的库，因此它具有如下特点：
异步。这里主要就是两个核心的方法 subscribeOn 和 observeOn。这两个方法都传入一个 Scheduler 对象，subscribeOn 指定产生事件的线程，observeOn 指定消费事件的线程。 强大的操作符。提供了一系列的转换操作符，可以将事件序列中的某个事件或整个事件序列进行加工处理，转换成不同的事件或事件序列，然后再发送出去。 简洁。由于采用链式调用的方式进行事件流的处理，RxJava 在应对较复杂的逻辑的时候，也能展现出清晰的思路。异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和 Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 观察者模式 # RxJava 有四个基本概念：Observable (可观察者，被观察者，生产者)、 Observer (观察者，消费者)、 subscribe (订阅)、Event (事件)。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，Observable 可以在需要的时候发出事件来通知 Observer，且 RxJava 支持事件以队列的形式连续发送。
角色 作用 被观察者（Observable） 产生事件 观察者（Observer） 接收事件，并给出响应动作 订阅（Subscribe） 连接 被观察者 &amp;amp; 观察者 事件（Event） 被观察者 &amp;amp; 观察者 沟通的载体 RxJava 的整体结构是一条链，其中：</description></item><item><title>Troubleshooting and FAQ</title><link>https://guanpj.github.io/amethyst/2023-03-22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/2023-03-22/</guid><description>Still having trouble? Here are a list of common questions and problems people encounter when installing Quartz.
While you&amp;rsquo;re here, join our Discord :)
Does Quartz have Latex support? # Yes! See CJK + Latex Support (测试) for a brief demo.
Can I use &amp;lt;Obsidian Plugin&amp;gt; in Quartz? # Unless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.</description></item><item><title>一、Binder 机制分析——概念篇</title><link>https://guanpj.github.io/amethyst/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87/</guid><description>上次没砍我的,这次我又来了。看完这篇还不明白 Binder 你砍我(一) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(二) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(三) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(四)完结篇 - 掘金
听说你 Binder 机制学的不错，来解决下这几个问题(一) - 掘金
听说你 Binder 机制学的不错，来解决下这几个问题(二) - 掘金
听说你 Binder 机制学的不错，来解决下这几个问题(三) - 掘金
3 分钟带你看懂 android 的 Binder 机制 - 掘金
图解 Android 中的 binder 机制 - 掘金
写给 Android 应用工程师的 Binder 原理剖析
Android 中 mmap 原理及应用简析 - 掘金</description></item><item><title>七、View 事件机制分析</title><link>https://guanpj.github.io/amethyst/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid><description>不知不觉，系列文章已经更新到第四篇了，从手机电源被按下到 App 被点击再到 UI 呈现在屏幕上，从系统内核到 framework 层再到应用层，期间发生了无数次交互，最终才使得我们五彩斑斓的 View 得于被渲染并出现在我们的眼前。可是，有了这些还不够，用户也是需要跟 App 进行交互的，其中最重要也是最直接的交互方式便是触摸手机屏幕了！
而我们的手指的触摸事件是怎样被一屏幕上的 View 感知的呢？本文将继续基于 Android Nougat 的源码来讲解这个过程。
触摸事件的产生 # ab cd 有硬件基础的同学应该都知道，计算机（当然包括手机）输入输出设备是通过触发硬件中断来
触摸事件的传递 # sdlfjsaldf
触摸事件的分发 # sdfk</description></item><item><title>三、Handler 原理分析</title><link>https://guanpj.github.io/amethyst/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>看完这篇还不明白 Handler 你砍我 - 掘金
基本使用 # Android 应用层通常使用 Handler 实现线程之间的消息通讯，Handler 是 Android 消息机制中非常重要的一员。以下分析通过剖析 Handler 的工作原理来深入了解 Android 应用开发过程中最常见也是最实用的消息收发机制。
在分析之前，先回顾一下 Handler 的使用方式：首先，最常用的是子线程往主线程发送消息：
Handler handler = new Handler() { @Override public void handleMessage(final Message msg) { Log.e(&amp;#34;gpj&amp;#34;, &amp;#34;Main thread handler received msg:&amp;#34; + msg.what); } }; //发送Message消息对象 Message message = handler.obtainMessage(); message.what = 0; message.obj = &amp;#34;Hello&amp;#34;; handler.sendMessage(message); //发送Runnable对象 handler.post(new Runnable() { @Override public void run() { Log.</description></item><item><title>二、Binder 机制分析——应用篇</title><link>https://guanpj.github.io/amethyst/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87/</guid><description>AIDL 是 Android Interface Definition Language（Android 接口定义语言）的缩写，它是 Android 进程间通信的接口语言。由于 Android 系统的 Linux 内核采用了进程隔离机制，使得不同的应用程序运行在不同的进程当中，有时候两个应用之间需要传递或者共享某些数据，就需要进行进程间的通信讯。
在上一篇文章——[[一、Binder 机制分析——概念篇]]中我们已经分析了使用 Binder 机制的原因以及分析了 Binder 机制，而 AIDL 也正是运用了 Binder 机制来实现进程间的通讯，本章我们将继续从 AIDL 的使用过程体验 Binder 在应用层的使用和原理。
AIDL 使用步骤 # 1、创建 .aidl 接口文件 # 首先在 aidl 文件夹这种新建文件并且命名为 IMyService.aidl，并且按照以下格式添加方法。此举是为了声明作为 Server 端的远程 Service 具有哪些能力：
package com.me.guanpj.binder; import com.me.guanpj.binder.User; // Declare any non-default types here with import statements interface IMyService { void addUser(in User user); List&amp;lt;User&amp;gt; getUserList(); } 对于对象引用，还需要引入实体类 User.</description></item><item><title>二叉树遍历</title><link>https://guanpj.github.io/amethyst/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</guid><description>import sys import io import json from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def preOrderIterate(self, root: TreeNode) -&amp;gt; List[int]: res = [] if not root: return res stack = [] node = root while node or stack: if node: res.</description></item><item><title>五、App 启动流程分析</title><link>https://guanpj.github.io/amethyst/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>在我的上一篇文章 Android 系统启动流程分析中，我们分析了系统在开机以后的一系列行为，其中最后一阶段 AMS(ActivityManagerService) 会启动 Launcher 来展示我们手机中所有已安装的应用图标，点击图标后相应的应用程序将会被系统启动运行并展示在我们面前，那么，点击了图标之后系统道理做了哪些工作呢？应用进程是怎么被启动的呢？Activity 的生命周期是什么时候被谁调用的呢？本文将继续基于 Android Nougat 的 frameworks 层源码的解答这些问题。
阅读建议：
如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。
1. Launcher —— AMS # 1.1 调用过程分析 # 1.1.1 Launcher.onClick # 在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 onClick 方法，
[packages/apps/Launcher3/src/com/android/launcher3/Launcher.java]( https://android.googlesource.com/platform/packages/apps/Launcher3/ /nougat-release/src/com/android/launcher3/Launcher.java?autodive=0/)：
public void onClick(View v) { ... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) { // 从快捷方式图标启动 onClickAppShortcut(v); } else if (tag instanceof FolderInfo) { // 文件夹 if (v instanceof FolderIcon) { onClickFolderIcon(v); } } else if (v == mAllAppsButton) { // “所有应用”按钮 onClickAllAppsButton(v); } else if (tag instanceof AppInfo) { // 从“所有应用”中启动的应用 startAppShortcutOrInfoActivity(v); } else if (tag instanceof LauncherAppWidgetInfo) { // 组件 if (v instanceof PendingAppWidgetHostView) { onClickPendingWidget((PendingAppWidgetHostView) v); } } } 1.</description></item><item><title>六、View 绘制流程分析</title><link>https://guanpj.github.io/amethyst/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>在我的系列文章上一篇： App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析 中已经分析了一个 App 从点击它的图标到 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用的整个流程。我们都知道，普通 App 屏幕上显示的内容都是由一个个自己设计的界面被系统加载而来的，而这些界面中的元素又是怎么被渲染出来的呢？本文将继续基于 Android Nougat 从源码的角度来进一步分析整个过程。
在开始之前，回顾一下上一篇文章中分析的从 ActivityThread 到 Activity 过程的时序图：
一：初始化 PhoneWindow 和 WindowManager # 如上图所示，在 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用之前，它的 attach() 方法将会先被调用，因此，我们将 attach() 方法作为这篇文章主线的开头：
final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) { attachBaseContext(context); .</description></item><item><title>四、系统启动流程分析</title><link>https://guanpj.github.io/amethyst/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>作为一名 Android 程序员，你有没有想过：那么复杂的 Android 系统，它是怎样运行起来的，我们的 App 又是怎样被 Android 系统加载后呈现在屏幕上的呢？Android 系统的启动是一个比较复杂的过程，涉及到了一些我们没有接触过的知识，本文将基于 Android Nougat 最新的代码上讲述 Android 系统的启动流程。
Bootloader —— 第一个程序 # 当按下电源键（加电）或者系统重启（复位）的时候，引导芯片会从 ROM（这里一般指 Flash ROM，即闪存）中预定义的位置将 Bootloader 载入到 RAM 中，接着，Bootloader 将会把 Linux 内核载入到 RAM 中并启动。
Bootloader 是在系统内核运行之前运行的一段小程序，也是系统运行的第一个程序，它的主要作用是：
初始化 RAM（一般指内存） 初始化硬件设备 加载内核和内存空间影像图 跳转到内核 init 进程 —— 1 号进程 # Linux 内核启动过程中会创建 init 进程，init 进程是用户空间的第一个进程（pid=1），对应的可执行程序的源文件文件为 [/system/core/init/Init.cpp]( https://android.googlesource.com/platform/system/core/ /nougat-release/init/init.cpp)，它的 main 方法如下：
int main(int argc, char** argv) { if (!strcmp(basename(argv[0]), &amp;#34;ueventd&amp;#34;)) { return ueventd_main(argc, argv); } if (!</description></item><item><title>容器类</title><link>https://guanpj.github.io/amethyst/%E5%AE%B9%E5%99%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%AE%B9%E5%99%A8%E7%B1%BB/</guid><description>全家福： Iterable 接口 # 可迭代的意思，实现此接口允许对象成为“for-each”循环语句的目标，提供 iterator 方法用于遍历元素。
public interface Iterable&amp;lt;T&amp;gt; { Iterator&amp;lt;T&amp;gt; iterator(); default void forEach(Consumer&amp;lt;? super T&amp;gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } default Spliterator&amp;lt;T&amp;gt; spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } } Iterator 意思为迭代器，它的定义如下：
public interface Iterator&amp;lt;E&amp;gt; { boolean hasNext(); E next(); default void remove() { throw new UnsupportedOperationException(&amp;#34;remove&amp;#34;); } default void forEachRemaining(Consumer&amp;lt;?</description></item><item><title>并发容器</title><link>https://guanpj.github.io/amethyst/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</guid><description>ConcurentHashMap # Java 7 实现 # Java 7 版本的 ConcurrentHashMap 数据结构示意图：
ConcurrentHashMap 内部进行了 Segment 分段，Segment 继承了 ReentrantLock，可以理解为一把锁，各个 Segment 之间都是相互独立上锁的，互不影响。相比于之前的 Hashtable 每次操作都需要把整个对象锁住而言，大大提高了并发效率。因为它的锁与锁之间是独立的，而不是整个对象只有一把锁。
每个 Segment 的底层数据结构与 HashMap 类似，仍然是数组和链表组成的拉链法结构。默认有 0~15 共 16 个 Segment，所以最多可以同时支持 16 个线程并发操作（操作分别分布在不同的 Segment 上）。16 这个默认值可以在初始化的时候设置为其他值，但是一旦确认初始化以后，是不可以扩容的。
构造方法 # public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor &amp;gt; 0) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &amp;gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments int sshift = 0; int ssize = 1; while (ssize &amp;lt; concurrencyLevel) { ++sshift; ssize &amp;lt;&amp;lt;= 1; } this.</description></item><item><title>泛型</title><link>https://guanpj.github.io/amethyst/%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E6%B3%9B%E5%9E%8B/</guid><description>什么是泛型？ # 声明中具有一个或者多个类型参数(type parameter)的类或者接口，就是泛型类或者接口。泛型类和接口统称为泛型(generic type)。
每种泛型定义一组类型形参(formal type parameters)，这些类型形参有时也被简称为类型参数(type parameter)，例如对于 List&amp;lt;E&amp;gt; 而言，List&amp;lt;String&amp;gt; 就是一个参数化的类型(parameterized type)，String 就是对应于类型形参(formal type parameters)的类型实参(actual type parameter)。
而如果 List&amp;lt;E&amp;gt; 不使用泛型参数，List 则为原生类型(raw type)。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。
每个泛型定义一个原生类型(raw type)，即不带任何类型参数的类型名称，例如，与 List&amp;lt;String&amp;gt; 对应的原生类型是 List。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。
Java 泛型是自 JDK5 起引入的一种参数化类型特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型泛型的本质是参数类型，也就是说所操作的数据类型被指定为一个参数。因为类型擦除机制，泛型不存在于 JVM 虚拟机。
为什么使用泛型？ # 1.使代码更健壮
2.使代码更简洁(不用强转)
3.使代码可复用性更高，程序更灵活
通俗地说，泛型是「有远⻅的创造者」创造的「方便使用者」的工具。也就是说，使用泛型能够让开发这编写出更加灵活的代码。
泛型的使用 # 作为类/接口的类型参数 # 可以在一个类或者接口里定义一个类型参数，等着子类/实现类去写出不同的实现：
public interface Comparable&amp;lt;T&amp;gt; { int compareTo(T o); .</description></item><item><title>注解和反射</title><link>https://guanpj.github.io/amethyst/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</guid><description>注解是什么？有何作用？ # Java 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。
注解本身没有任何意义，单独的注解就是一种注释，他需要结合其他如反射、插桩等技术才有意义。
元注解 # 在 JDK 中提供了 4 个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：
@Target # Target 注解的作用是：描述注解的使用范围(即被修饰的注解可以用在什么地方).
Target 注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数），在定义注解类时使用了 @Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在 ElementType 枚举中.
源码：
@Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Target { ElementType[] value(); } ElementType定义： public enum ElementType { TYPE, // 类、接口、枚举类 FIELD, // 成员变量（包括：枚举常量） METHOD, // 成员方法 PARAMETER, // 方法参数 CONSTRUCTOR, // 构造方法 LOCAL_VARIABLE, // 局部变量 ANNOTATION_TYPE, // 注解类 PACKAGE, // 可用于修饰：包 TYPE_PARAMETER, // 类型参数，JDK 1.</description></item><item><title>等待-通知机制</title><link>https://guanpj.github.io/amethyst/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</guid><description>wait/notify 模式 # public class MyBlockingQueueForWaitNotify {
 private int maxSize = 16;
 private LinkedList storage;
  public MyBlockingQueueForWaitNotify (int size) {
 this.maxSize = size;
 storage = new LinkedList&amp;lt;&amp;gt;();
 }
  public synchronized void put() throws InterruptedException {
 while (storage.size() == maxSize) {
 this.wait();
 }
 storage.add(new Object());
 this.notifyAll();
 }
  public synchronized void take() throws InterruptedException {</description></item><item><title>线程协作</title><link>https://guanpj.github.io/amethyst/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/</guid><description>Thread.join() # 使用 # public class UseJoin { public static void main(String[] args) { final Thread thread1 = new Thread(() -&amp;gt; { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&amp;#34;thread 1 is running&amp;#34;); }); final Thread thread2 = new Thread(() -&amp;gt; { try { thread1.join(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.</description></item><item><title>线程基础</title><link>https://guanpj.github.io/amethyst/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid><description>CPU 核心数和线程数的关系 # 增加 CPU 核心数目就是为了增加线程数，因为操作系统是通过线程来执行任务的，一般情况下它们是 1:1 对应关系，也就是说四核 CPU 一般拥有四个线程。但 Intel 引入超线程技术后，使核心数与线程数形成 1:2 的关系。
进程和线程 # 进程是程序运行资源分配的最小单位 # 进程是操作系统进行资源分配的最小单位，其中资源包括：CPU、内存空间、磁盘等，同一进程中的多条线程共享该进程中的全部系统资源，而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的、静态的，进程是活的、动态的。
进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身，用户进程就是所有由你启动的进程。
线程是 CPU 调度的最小单位，必须依赖于进程而存在 # 线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的、能独立运行的基本单位。
线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
线程无处不在，任何一个程序都必须要创建线程。特别是 Java，不管任何程序都必须启动一个 main 函数的主线程；Java Web 开发里面的定时任务、定时器、JSP 和 Servlet、异步消息处理机制，远程访问接口 RM 等；Android 中的任何一个 onClick 事件的触发事件等都离不开线程和并发的知识。
并行和并发 # 举个例子，如果有条高速公路 A 上面并排有 8 条车道，那么最大的并行车辆就是 8 辆，此条高速公路 A 同时并排行走的车辆小于等于 8 辆的时候，车辆就可以并行运行。CPU 也是这个原理，一个 CPU 相当于一个高速公路 A，核心数或者线程数就相当于并排可以通行的车道；而多个 CPU 就相当于并排有多条高速公路，而每个高速公路并排有多个车道。
当谈论并发的时候一定要加个单位时间，也就是说单位时间内并发量是多少？离开了单位时间其实是没有意义的。
原则上一个 CPU 只能分配给一个进程，以便运行这个进程。我们通常使用的计算机中只有一个 CPU，也就是说只有一颗心，要让它一心多用同时运行多个进程，就必须使用并发技术。实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”。</description></item><item><title>线程池和 BlockingQueue</title><link>https://guanpj.github.io/amethyst/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue/</guid><description>BlockingQueue 阻塞队列 # 队列 # 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。
什么是阻塞队列 # public interface BlockingQueue&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt;
支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。
抛出异常：当队列满时，如果再往队列里插入元素，会抛出 IllegalStateException（&amp;ldquo;Queuefull&amp;rdquo;）异常。当队列空时，从队列里获取元素会抛出 NoSuchElementException 异常。 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回 true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null。 一直阻塞：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里 take 元素，队列会阻塞住消费者线程，直到队列不为空。 超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。 常用阻塞队列 # ArrayBlockingQueue # 用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列。可在初始化时通过参数设置，默认是非公平的。
所谓公平访问队列是指阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。
LinkedBlockingQueue # 用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。
PriorityBlockingQueue # 支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。
DelayQueue # 支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。DelayQueue 非常有用，可以将 DelayQueue 运用在缓存系统的设计：用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</description></item><item><title>编码、加密、Hash、序列化和字符集</title><link>https://guanpj.github.io/amethyst/%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/</guid><description>加密 # 在密码学中，加密是将明文信息改变为难以读取的密文内容，使之不可读的过程。只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。理想情况下，只有经授权的人员能够读取密文所要传达的信息。加密本身并不能防止信息传输被截取，但加密能防止截取者理解其内容。
对称加密 # 原理 # 通信双方使用同一个密钥，使用加密算法配合上密钥来加密，解密时使用加密过程
的完全逆过程配合密钥来进行解密。
经典算法 # DES(56 位密钥，密钥太短而逐渐被弃用) AES(128 位、192 位、256 位密钥， 现在最流行) 对称加密作用 # 加密通信，防止信息在不安全网络上被截获后，信息被人读取或篡改。
对称加密(如 AES)的破解 # 破解思路
拿到一组或多组原文-密文对 设法找到一个密钥，这个密钥可以将这些原文-密文对中的原文加密为密文，以 及将密文解密为原文的组合，即为成功破解
反破解
一种优秀的对称加密算法的标准是，让破解者找不到比穷举法(暴力破解法)更有
效的破解手段，并且穷举法的破解时间足够⻓(例如数千年)。
对称加密的缺点 # 密钥泄露：不能在不安全网络上传输密钥，一旦密钥泄露则加密通信失败。
非对称加密 # 原理 # 使用公钥对数据进行加密得到密文;使用私钥对数据进行解密得到原数据。
使用非对称加密通信，可以在不可信网络上将双方的公钥传给对方，然后在发消息前分别对消息使用对方的公钥来加密和使用自己的私钥来签名，做到不可信网络上的可靠密钥传播及加密通信。
由于私钥和公钥互相可解，因此非对称加密还可以应用于数字签名技术。通常会对原数据 hash 以后对 hash 签名，然后附加在原数据的后面作为签名。这是 为了让数据更小。
经典算法 # RSA(可用于加密和签名) DSA(仅用于 签名，但速度更快) 非对称加密的优缺点 # 优点：可以在不安全网络上传输密钥。 缺点：计算复杂，因此性能相比对称加密差很多。 非对称加密(如 RSA、ECDSA)的破解 # 破解思路 # 和对称加密不同之处在于，非对称加密的公钥很容易获得，因此制造“原文-密文”对是没有困难的事。所以，非对称加密的关键只在于如何找到一个正确的私钥，可以解密所有经过公钥加密过的密文。找到这样的私钥即为成功破解。由于非对称加密的自身特性，怎样通过公钥来推断出私钥通常是一种思路(例如 RSA)，但往往最佳手段依然是穷举法，只是和对称加密破解的区别在于，对称加密破解是不断尝试自己的新密钥是否可以将自己拿到的“原文-密文”对进行加密和解密，而非对称加密时不断尝试自己的新私钥是否和公钥互相可解。</description></item><item><title>计算机网络体系结构、TCP&amp;IP 和 HTTPS</title><link>https://guanpj.github.io/amethyst/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84TCPIP-%E5%92%8C-HTTPS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84TCPIP-%E5%92%8C-HTTPS/</guid><description>为什么需要计算机网络体系结构？ # 计算机网络是个非常复杂的系统。比如，连接在网络上的两台计算机需要进行通信时，由于计算机网络的复杂性和异质性，需要考虑很多复杂的因素，比如：
这两台计算机之间必须有一条传送数据的通路； 告诉网络如何识别接收数据的计算机； 发起通信的计算机必须保证要传送的数据能在这条通路上正确发送和接收； 对出现的各种差错和意外事故，如数据传送错误、网络中某个节点交换机出现故障等问题，应该有可靠完善的措施保证对方计算机最终能正确收到数据。 计算机网络体系结构标准的制定正是为了解决这些问题，要想完成这种网络通信就必须保证相互通信的这两个计算机系统达成高度默契。事实上，在网络通信领域，两台计算机(网络设备)之间的通信并不像人与人之间的交流那样自然天然，这种计算机间高度默契的交流(通信) 背后需要十分复杂、完备的网络体系结构作为支撑。那么，用什么方法才能合理地组织网络的结构，以保证其具有结构清晰、设计与实现简化、便于更新和维护、较强的独立性和适应性，从而使网络设备之间具有这种 “高度默契” 呢？答案是分而治之，更进一步地说就是分层思想。
计算机网络体系结构设计基本思想 # 分层思想在日常生活中的应用 # 在快递系统中，用户和用户之间的通信依赖于下层的服务，但是他们并不需要关心快递、运输等细节，也就是说，寄信者只需将写好的信交给快递员而收信者只需从快递员手中查收信件即可。类似地，快递员也只需要从寄信人手中拿到信件并交给分检员或将信件从分检员手中拿走并交给收信人即可，至于分检员为何要把这份信交给他进行投递(事实上，每个快递员会负责某个片区，分检员根据收信人地址将信件分发给不同的快递员)，他不需要关心也没必要关心。显然，在这个快递系统中，各个角色（用户、快递员…）在功能上相互独立却又能协调合作达成一种 “高度默契”，这在很大程度上得益于分层思想的理念和应用。
分层思想的优点 # 耦合度低(独立性强)。上层只需通过下层为上层提供的接口来使用下层所实现的服务，而不需要关心下层的具体实现。也就是说，下层对上层而言就是具有一定功能的黑箱。 适应性强。只要每层为上层提供的服务和接口不变，每层的实现细节可以任意改变。 易于实现和维护。把复杂的系统分解成若干个涉及范围小且功能简单的子单元，从而使得系统结构清晰，实现、调试和维护都变得简单和容易。也就是说，对于设计/开发人员而言，这种方法使设计/开发人员能够专心设计和开发他们所关心的功能模块；对于调试/维护人员而言，这种方法也方便调试/维护人员去处理他们所负责的功能模块。 计算机网络体系结构的概念与标准 # 计算机网络体系结构的概念 # 计算机网络体系结构必须包括三个内容，即分层结构与每层的功能，服务与层间接口和协议。所以，计算机网络体系结构的定义为：在计算机网络中，层、层间接口及协议的集合。
计算机网络体系结构的标准 # 目前，由国际化标准组织 ISO 制定的网络体系结构国际标准是 OSI 七层模型，但实际中应用最广泛的是 TCP/IP 体系结构。换句话说，OSI 七层模型只是理论上的、官方制定的国际标准，而TCP/IP 体系结构才是事实上的国际标准。这看起来是不可理喻的，但这却是实际存在的，这是由一些历史原因造成的。OSI 标准的制定者以专家、学者为主，他们缺乏实际经验和商业驱动力，并且 OSI 标准自身运行效率也不怎么好。与此同时，由于 Inernet 在全世界覆盖了相当大的范围，并且占领市场的标准是 TCP/IP 体系结构，因此导致 OSI 标准没有市场背景，也就只是理论上的成果，并没有过多地应用于实践。
TCP/IP 四层体系结构 # TCP/IP 是 Internet 上的标准通信协议集，该协议集由数十个具有层次结构的协议组成，其中 TCP 和 IP 是该协议集中的两个最重要的核心协议。TCP/IP 协议族按层次可分为以下四层：应用层、传输层、网络层和网络接口层，各层对应的 PDU 数据单元的名称如下图所示。</description></item><item><title>锁</title><link>https://guanpj.github.io/amethyst/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E9%94%81/</guid><description>锁的分类 # 偏向锁/轻量级锁/重量级锁 # Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级但不能降级。
这些状态被记录在对象头中的 mark word 中。
偏向锁 # 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。
轻量级锁 # JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。
重量级锁 # 重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。
对比 # 可重入锁/非可重入锁 # 可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。
对于可重入锁而言，最典型的就是 ReentrantLock 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类。synchronized 锁也属于可重入锁。
共享锁/独占锁（排他锁） # 共享锁指的是我们同一把锁可以被多个线程同时获得；而独占锁（排他锁）指的就是，这把锁只能同时被一个线程获得。读写锁就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。
公平锁/非公平锁 # 概念 # 公平锁之公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。
那么什么“一定情况下”呢？假设当前线程在请求获取锁的时候，恰巧前一个持有锁的线程释放了这把锁，那么当前申请锁的线程就可以不顾已经等待的线程而选择立刻插队。但是如果当前线程请求的时候，前一个线程并没有在那一时刻释放锁，那么当前线程还是一样会进入等待队列。
原理 # 分析公平和非公平锁的源码，具体看下它们是怎样实现的：
public class ReentrantLock implements Lock, java.</description></item></channel></rss>