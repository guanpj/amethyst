<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Framework on</title><link>https://guanpj.github.io/amethyst/tags/Framework/</link><description>Recent content in Framework on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/tags/Framework/index.xml" rel="self" type="application/rss+xml"/><item><title>一、Binder 机制分析——概念篇</title><link>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87/</guid><description>上次没砍我的,这次我又来了。看完这篇还不明白 Binder 你砍我(一) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(二) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(三) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(四)完结篇 - 掘金
听说你 Binder 机制学的不错，来解决下这几个问题(一) - 掘金
听说你 Binder 机制学的不错，来解决下这几个问题(二) - 掘金
听说你 Binder 机制学的不错，来解决下这几个问题(三) - 掘金
3 分钟带你看懂 android 的 Binder 机制 - 掘金
图解 Android 中的 binder 机制 - 掘金
写给 Android 应用工程师的 Binder 原理剖析
Android 中 mmap 原理及应用简析 - 掘金</description></item><item><title>七、View 事件机制分析</title><link>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid><description>不知不觉，系列文章已经更新到第四篇了，从手机电源被按下到 App 被点击再到 UI 呈现在屏幕上，从系统内核到 framework 层再到应用层，期间发生了无数次交互，最终才使得我们五彩斑斓的 View 得于被渲染并出现在我们的眼前。可是，有了这些还不够，用户也是需要跟 App 进行交互的，其中最重要也是最直接的交互方式便是触摸手机屏幕了！
而我们的手指的触摸事件是怎样被一屏幕上的 View 感知的呢？本文将继续基于 Android Nougat 的源码来讲解这个过程。
触摸事件的产生 # ab cd 有硬件基础的同学应该都知道，计算机（当然包括手机）输入输出设备是通过触发硬件中断来
触摸事件的传递 # sdlfjsaldf
触摸事件的分发 # sdfk</description></item><item><title>三、Handler 原理分析</title><link>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>看完这篇还不明白 Handler 你砍我 - 掘金
基本使用 # Android 应用层通常使用 Handler 实现线程之间的消息通讯，Handler 是 Android 消息机制中非常重要的一员。以下分析通过剖析 Handler 的工作原理来深入了解 Android 应用开发过程中最常见也是最实用的消息收发机制。
在分析之前，先回顾一下 Handler 的使用方式：首先，最常用的是子线程往主线程发送消息：
Handler handler = new Handler() { @Override public void handleMessage(final Message msg) { Log.e(&amp;#34;gpj&amp;#34;, &amp;#34;Main thread handler received msg:&amp;#34; + msg.what); } }; //发送Message消息对象 Message message = handler.obtainMessage(); message.what = 0; message.obj = &amp;#34;Hello&amp;#34;; handler.sendMessage(message); //发送Runnable对象 handler.post(new Runnable() { @Override public void run() { Log.</description></item><item><title>二、Binder 机制分析——应用篇</title><link>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87/</guid><description>AIDL 是 Android Interface Definition Language（Android 接口定义语言）的缩写，它是 Android 进程间通信的接口语言。由于 Android 系统的 Linux 内核采用了进程隔离机制，使得不同的应用程序运行在不同的进程当中，有时候两个应用之间需要传递或者共享某些数据，就需要进行进程间的通信讯。
在上一篇文章——[[一、Binder 机制分析——概念篇]]中我们已经分析了使用 Binder 机制的原因以及分析了 Binder 机制，而 AIDL 也正是运用了 Binder 机制来实现进程间的通讯，本章我们将继续从 AIDL 的使用过程体验 Binder 在应用层的使用和原理。
AIDL 使用步骤 # 1、创建 .aidl 接口文件 # 首先在 aidl 文件夹这种新建文件并且命名为 IMyService.aidl，并且按照以下格式添加方法。此举是为了声明作为 Server 端的远程 Service 具有哪些能力：
package com.me.guanpj.binder; import com.me.guanpj.binder.User; // Declare any non-default types here with import statements interface IMyService { void addUser(in User user); List&amp;lt;User&amp;gt; getUserList(); } 对于对象引用，还需要引入实体类 User.</description></item><item><title>五、App 启动流程分析</title><link>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>在我的上一篇文章 Android 系统启动流程分析中，我们分析了系统在开机以后的一系列行为，其中最后一阶段 AMS(ActivityManagerService) 会启动 Launcher 来展示我们手机中所有已安装的应用图标，点击图标后相应的应用程序将会被系统启动运行并展示在我们面前，那么，点击了图标之后系统道理做了哪些工作呢？应用进程是怎么被启动的呢？Activity 的生命周期是什么时候被谁调用的呢？本文将继续基于 Android Nougat 的 frameworks 层源码的解答这些问题。
阅读建议：
如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。
1. Launcher —— AMS # 1.1 调用过程分析 # 1.1.1 Launcher.onClick # 在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 onClick 方法，
[packages/apps/Launcher3/src/com/android/launcher3/Launcher.java]( https://android.googlesource.com/platform/packages/apps/Launcher3/ /nougat-release/src/com/android/launcher3/Launcher.java?autodive=0/)：
public void onClick(View v) { ... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) { // 从快捷方式图标启动 onClickAppShortcut(v); } else if (tag instanceof FolderInfo) { // 文件夹 if (v instanceof FolderIcon) { onClickFolderIcon(v); } } else if (v == mAllAppsButton) { // “所有应用”按钮 onClickAllAppsButton(v); } else if (tag instanceof AppInfo) { // 从“所有应用”中启动的应用 startAppShortcutOrInfoActivity(v); } else if (tag instanceof LauncherAppWidgetInfo) { // 组件 if (v instanceof PendingAppWidgetHostView) { onClickPendingWidget((PendingAppWidgetHostView) v); } } } 1.</description></item><item><title>六、View 绘制流程分析</title><link>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>在我的系列文章上一篇： App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析 中已经分析了一个 App 从点击它的图标到 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用的整个流程。我们都知道，普通 App 屏幕上显示的内容都是由一个个自己设计的界面被系统加载而来的，而这些界面中的元素又是怎么被渲染出来的呢？本文将继续基于 Android Nougat 从源码的角度来进一步分析整个过程。
在开始之前，回顾一下上一篇文章中分析的从 ActivityThread 到 Activity 过程的时序图：
一：初始化 PhoneWindow 和 WindowManager # 如上图所示，在 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用之前，它的 attach() 方法将会先被调用，因此，我们将 attach() 方法作为这篇文章主线的开头：
final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) { attachBaseContext(context); .</description></item><item><title>四、系统启动流程分析</title><link>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>作为一名 Android 程序员，你有没有想过：那么复杂的 Android 系统，它是怎样运行起来的，我们的 App 又是怎样被 Android 系统加载后呈现在屏幕上的呢？Android 系统的启动是一个比较复杂的过程，涉及到了一些我们没有接触过的知识，本文将基于 Android Nougat 最新的代码上讲述 Android 系统的启动流程。
Bootloader —— 第一个程序 # 当按下电源键（加电）或者系统重启（复位）的时候，引导芯片会从 ROM（这里一般指 Flash ROM，即闪存）中预定义的位置将 Bootloader 载入到 RAM 中，接着，Bootloader 将会把 Linux 内核载入到 RAM 中并启动。
Bootloader 是在系统内核运行之前运行的一段小程序，也是系统运行的第一个程序，它的主要作用是：
初始化 RAM（一般指内存） 初始化硬件设备 加载内核和内存空间影像图 跳转到内核 init 进程 —— 1 号进程 # Linux 内核启动过程中会创建 init 进程，init 进程是用户空间的第一个进程（pid=1），对应的可执行程序的源文件文件为 [/system/core/init/Init.cpp]( https://android.googlesource.com/platform/system/core/ /nougat-release/init/init.cpp)，它的 main 方法如下：
int main(int argc, char** argv) { if (!strcmp(basename(argv[0]), &amp;#34;ueventd&amp;#34;)) { return ueventd_main(argc, argv); } if (!</description></item></channel></rss>