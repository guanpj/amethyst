<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Glide on</title><link>https://guanpj.github.io/amethyst/tags/Glide/</link><description>Recent content in Glide on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/tags/Glide/index.xml" rel="self" type="application/rss+xml"/><item><title>Glide 加载流程和缓存原理分析</title><link>https://guanpj.github.io/amethyst/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>加载流程 # Glide 最普通的用法如下：
Glide.with(this).load(url).into(textView);
以首次加载 url 指向的资源到 textView 对象为例，由于代码实在太过冗长，下面用流程图的方式表示各个环节的执行顺序。
with # with 流程的主要职责：
创建 RequestManager 对象 初始化各式各样的配置信息（缓存、请求线程池、图片大小和格式等等）以及 Glide 单例对象。 将 Glide 请求和 application/Activity/SupportFragment/Fragment 的生命周期绑定在一起，从而实现自动执行请求，暂停操作。 public class Glide implements ComponentCallbacks2 { ... @NonNull public static RequestManager with(@NonNull Context context) { return getRetriever(context).get(context); } @NonNull public static RequestManager with(@NonNull Activity activity) { return getRetriever(activity).get(activity); } @NonNull public static RequestManager with(@NonNull FragmentActivity activity) { return getRetriever(activity).</description></item><item><title>Glide 基本使用</title><link>https://guanpj.github.io/amethyst/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>准备 # 添加依赖 # implementation &amp;#39;com.github.bumptech.glide:glide:4.12.0&amp;#39; annotationProcessor &amp;#39;com.github.bumptech.glide:compiler:4.12.0&amp;#39; 添加网路权限 # &amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; 定义控件 # &amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;Button android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;load&amp;#34; app:layout_constraintLeft_toLeftOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; android:onClick=&amp;#34;load&amp;#34;/&amp;gt; &amp;lt;ImageView android:id=&amp;#34;@+id/image&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:src=&amp;#34;@mipmap/ic_launcher&amp;#34; app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34; app:layout_constraintLeft_toLeftOf=&amp;#34;parent&amp;#34; app:layout_constraintRight_toRightOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 加载图片 # 添加按钮监听，使用 Glide 加载网路图片：</description></item><item><title>Glide 高级用法</title><link>https://guanpj.github.io/amethyst/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid><description>回调与监听 # Target # 我们都知道，使用 Glide 在界面上加载并展示一张图片只需要一行代码：
Glide.with(this).load(url).into(imageView); 将 ImageView 的实例传入到 into() 方法当中，Glide 将图片加载完成之后，图片就能显示到 ImageView 上了。这是怎么实现的呢？来看一下 into() 方法的源码：
@NonNull public ViewTarget&amp;lt;ImageView, TranscodeType&amp;gt; into(@NonNull ImageView view) { Util.assertMainThread(); Preconditions.checkNotNull(view); BaseRequestOptions&amp;lt;?&amp;gt; requestOptions = this; if (!requestOptions.isTransformationSet() &amp;amp;&amp;amp; requestOptions.isTransformationAllowed() &amp;amp;&amp;amp; view.getScaleType() != null) { // Clone in this method so that if we use this RequestBuilder to load into a View and then // into a different target, we don&amp;#39;t retain the transformation applied based on the previous // View&amp;#39;s scale type.</description></item></channel></rss>