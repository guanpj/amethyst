<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Message on</title><link>https://guanpj.github.io/amethyst/tags/Message/</link><description>Recent content in Message on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/tags/Message/index.xml" rel="self" type="application/rss+xml"/><item><title>三、Handler 原理分析</title><link>https://guanpj.github.io/amethyst/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>看完这篇还不明白 Handler 你砍我 - 掘金
基本使用 # Android 应用层通常使用 Handler 实现线程之间的消息通讯，Handler 是 Android 消息机制中非常重要的一员。以下分析通过剖析 Handler 的工作原理来深入了解 Android 应用开发过程中最常见也是最实用的消息收发机制。
在分析之前，先回顾一下 Handler 的使用方式：首先，最常用的是子线程往主线程发送消息：
Handler handler = new Handler() { @Override public void handleMessage(final Message msg) { Log.e(&amp;#34;gpj&amp;#34;, &amp;#34;Main thread handler received msg:&amp;#34; + msg.what); } }; //发送Message消息对象 Message message = handler.obtainMessage(); message.what = 0; message.obj = &amp;#34;Hello&amp;#34;; handler.sendMessage(message); //发送Runnable对象 handler.post(new Runnable() { @Override public void run() { Log.</description></item></channel></rss>