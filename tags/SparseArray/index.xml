<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SparseArray on</title><link>https://guanpj.github.io/amethyst/tags/SparseArray/</link><description>Recent content in SparseArray on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/tags/SparseArray/index.xml" rel="self" type="application/rss+xml"/><item><title>Android 对容器类的优化</title><link>https://guanpj.github.io/amethyst/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96/</guid><description>在之前 HashMap 的源码解析的文章 中可知，HashMap 的一级存储结构是一个初始容量为 16 的数组， 所以当我们创建出一个 HashMap 对象时，即使里面没有任何元素，也要分别一块内存空间给它。而且，在不断的向 HashMap 里 put 数据的过程中，当数据量达到阈值（容量 * 加载因子，加载因子默认为 0.75）时，将会触发 HashMap 扩容流程，扩大后新的容量一定是原来的 2 倍。
假如我们有几十万、几百万条数据，那么 HashMap 要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做 hash 运算，这将对我们的内存空间造成很大消耗和浪费，再加上 HashMap 获取数据是通过遍历 Entry[] 数组来得到对应的元素，在数据量很大时候会比较慢。
所以对于运行在移动设备上的 Android 系统来说，HashMap 的使用会造成比较大的负担。因此在
android.util 包中，提供了几个容器类，在某些情况下可以取代 HashMap 以提升性能。
SparseArray # 相比于比 HashMap ，SparseArray 更省内存，并且在某些条件下性能更好，主要是因为它避免了对 key 的自动装箱（int 转为 Integer 类型）。与普通的对象数组不同，它的索引可以包含间隙，因此得名 SparseArray（稀疏数组）。它的内部采用数组来存储 key，并且通过二分查找定位到目标 key，因此在数据量达到数百个时，效率将会降低至少 50% 之于 HashMap。
为了提高性能，在删除某项数据时，SparseArray 并不会马上删除 value 中的内容并且压缩整理 key 数组，而是会把将要删除的数据标记成 DELETE，后续可以重新用于相同 key 值的数据或者在 gc 操作的时候进行删除。SparseArray 在进行扩容前或者调用 size、indexOfKey 等方法时必须进行 gc 操作。</description></item></channel></rss>