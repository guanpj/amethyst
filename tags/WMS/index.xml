<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WMS on</title><link>https://guanpj.github.io/amethyst/tags/WMS/</link><description>Recent content in WMS on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/tags/WMS/index.xml" rel="self" type="application/rss+xml"/><item><title>六、View 绘制流程分析</title><link>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Knowledge/Android/Framework/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>在我的系列文章上一篇： App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析 中已经分析了一个 App 从点击它的图标到 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用的整个流程。我们都知道，普通 App 屏幕上显示的内容都是由一个个自己设计的界面被系统加载而来的，而这些界面中的元素又是怎么被渲染出来的呢？本文将继续基于 Android Nougat 从源码的角度来进一步分析整个过程。
在开始之前，回顾一下上一篇文章中分析的从 ActivityThread 到 Activity 过程的时序图：
一：初始化 PhoneWindow 和 WindowManager # 如上图所示，在 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用之前，它的 attach() 方法将会先被调用，因此，我们将 attach() 方法作为这篇文章主线的开头：
final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) { attachBaseContext(context); .</description></item></channel></rss>