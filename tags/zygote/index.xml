<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zygote on</title><link>https://guanpj.github.io/amethyst/tags/zygote/</link><description>Recent content in zygote on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/tags/zygote/index.xml" rel="self" type="application/rss+xml"/><item><title>五、App 启动流程分析</title><link>https://guanpj.github.io/amethyst/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>在我的上一篇文章 Android 系统启动流程分析中，我们分析了系统在开机以后的一系列行为，其中最后一阶段 AMS(ActivityManagerService) 会启动 Launcher 来展示我们手机中所有已安装的应用图标，点击图标后相应的应用程序将会被系统启动运行并展示在我们面前，那么，点击了图标之后系统道理做了哪些工作呢？应用进程是怎么被启动的呢？Activity 的生命周期是什么时候被谁调用的呢？本文将继续基于 Android Nougat 的 frameworks 层源码的解答这些问题。
阅读建议：
如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。
1. Launcher —— AMS # 1.1 调用过程分析 # 1.1.1 Launcher.onClick # 在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 onClick 方法，
[packages/apps/Launcher3/src/com/android/launcher3/Launcher.java]( https://android.googlesource.com/platform/packages/apps/Launcher3/ /nougat-release/src/com/android/launcher3/Launcher.java?autodive=0/)：
public void onClick(View v) { ... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) { // 从快捷方式图标启动 onClickAppShortcut(v); } else if (tag instanceof FolderInfo) { // 文件夹 if (v instanceof FolderIcon) { onClickFolderIcon(v); } } else if (v == mAllAppsButton) { // “所有应用”按钮 onClickAllAppsButton(v); } else if (tag instanceof AppInfo) { // 从“所有应用”中启动的应用 startAppShortcutOrInfoActivity(v); } else if (tag instanceof LauncherAppWidgetInfo) { // 组件 if (v instanceof PendingAppWidgetHostView) { onClickPendingWidget((PendingAppWidgetHostView) v); } } } 1.</description></item><item><title>四、系统启动流程分析</title><link>https://guanpj.github.io/amethyst/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>作为一名 Android 程序员，你有没有想过：那么复杂的 Android 系统，它是怎样运行起来的，我们的 App 又是怎样被 Android 系统加载后呈现在屏幕上的呢？Android 系统的启动是一个比较复杂的过程，涉及到了一些我们没有接触过的知识，本文将基于 Android Nougat 最新的代码上讲述 Android 系统的启动流程。
Bootloader —— 第一个程序 # 当按下电源键（加电）或者系统重启（复位）的时候，引导芯片会从 ROM（这里一般指 Flash ROM，即闪存）中预定义的位置将 Bootloader 载入到 RAM 中，接着，Bootloader 将会把 Linux 内核载入到 RAM 中并启动。
Bootloader 是在系统内核运行之前运行的一段小程序，也是系统运行的第一个程序，它的主要作用是：
初始化 RAM（一般指内存） 初始化硬件设备 加载内核和内存空间影像图 跳转到内核 init 进程 —— 1 号进程 # Linux 内核启动过程中会创建 init 进程，init 进程是用户空间的第一个进程（pid=1），对应的可执行程序的源文件文件为 [/system/core/init/Init.cpp]( https://android.googlesource.com/platform/system/core/ /nougat-release/init/init.cpp)，它的 main 方法如下：
int main(int argc, char** argv) { if (!strcmp(basename(argv[0]), &amp;#34;ueventd&amp;#34;)) { return ueventd_main(argc, argv); } if (!</description></item></channel></rss>