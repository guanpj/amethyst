<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>动态代理 on</title><link>https://guanpj.github.io/amethyst/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><description>Recent content in 动态代理 on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>ADB 命令</title><link>https://guanpj.github.io/amethyst/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>代理模式是软件开发中常见的设计模式，它的目的是让调用者不用持有具体操作者的引用，而是通过代理者去对具体操作者执行具体的操作。本文通过使用静态代理和动态代理分别实现代理模式，来对比和分析两者的实现原理。
静态代理的实现 # 代理接口：
public interface Person {  String doSomething(int i); } 目标对象：
public class Worker implements Person {  @Override  public String doSomething(int i) {  System.out.println(&amp;#34;I&amp;#39;m doing something by param: &amp;#34; + i);  } } 代理对象：
public class PersonProxy implements Person {  private Worker worker = null;  @Override  public String doSomething(int i) {  beforeDoSomething();  if(worker == null) {  worker = new Worker();  }  Stirng result = worker.</description></item></channel></rss>