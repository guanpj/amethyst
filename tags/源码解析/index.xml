<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码解析 on</title><link>https://guanpj.github.io/amethyst/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><description>Recent content in 源码解析 on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://guanpj.github.io/amethyst/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>EventBus 使用及源码解析</title><link>https://guanpj.github.io/amethyst/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>使用 # 首先引入依赖 apply plugin: &amp;#39;kotlin-kapt&amp;#39; dependencies { implementation &amp;#39;org.greenrobot:eventbus:3.2.0&amp;#39; kapt &amp;#39;org.greenrobot:eventbus-annotation-processor:3.2.0&amp;#39; } kapt { arguments { arg(&amp;#39;eventBusIndex&amp;#39;, &amp;#39;com.me.guanpj.myapplication.MyEventBusIndex&amp;#39;) } } 从在 3.0 版本开始，EventBus 提供了一个 EventBusAnnotationProcessor 注解处理器来在编译期通过读取 @Subscribe 注解，并解析和处理其中所包含的信息，然后生成 Java 类索引来保存订阅者中所有的事件响应函数，这样就比在运行时使用反射来获得订阅者中所有事件响应函数的速度要快。
以下是来自官方对 EventBus 各个版本性能的对比图，可以看到，EventBus 3.x 如果没有使用索引的话性能相较于之前的版本是倒退的。使用索引能让 EventBus 的性能大大增加。
添加混淆规则： -keepattributes *Annotation* -keepclassmembers class * { @org.greenrobot.eventbus.Subscribe &amp;lt;methods&amp;gt;; } -keep enum org.greenrobot.eventbus.ThreadMode { *; } # And if you use AsyncExecutor: -keepclassmembers class * extends org.</description></item><item><title>Glide 加载流程和缓存原理分析</title><link>https://guanpj.github.io/amethyst/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>加载流程 # Glide 最普通的用法如下：
Glide.with(this).load(url).into(textView);
以首次加载 url 指向的资源到 textView 对象为例，由于代码实在太过冗长，下面用流程图的方式表示各个环节的执行顺序。
with # with 流程的主要职责：
创建 RequestManager 对象 初始化各式各样的配置信息（缓存、请求线程池、图片大小和格式等等）以及 Glide 单例对象。 将 Glide 请求和 application/Activity/SupportFragment/Fragment 的生命周期绑定在一起，从而实现自动执行请求，暂停操作。 public class Glide implements ComponentCallbacks2 { ... @NonNull public static RequestManager with(@NonNull Context context) { return getRetriever(context).get(context); } @NonNull public static RequestManager with(@NonNull Activity activity) { return getRetriever(activity).get(activity); } @NonNull public static RequestManager with(@NonNull FragmentActivity activity) { return getRetriever(activity).</description></item><item><title>Glide 基本使用</title><link>https://guanpj.github.io/amethyst/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>准备 # 添加依赖 # implementation &amp;#39;com.github.bumptech.glide:glide:4.12.0&amp;#39; annotationProcessor &amp;#39;com.github.bumptech.glide:compiler:4.12.0&amp;#39; 添加网路权限 # &amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; 定义控件 # &amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;Button android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;load&amp;#34; app:layout_constraintLeft_toLeftOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; android:onClick=&amp;#34;load&amp;#34;/&amp;gt; &amp;lt;ImageView android:id=&amp;#34;@+id/image&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:src=&amp;#34;@mipmap/ic_launcher&amp;#34; app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34; app:layout_constraintLeft_toLeftOf=&amp;#34;parent&amp;#34; app:layout_constraintRight_toRightOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 加载图片 # 添加按钮监听，使用 Glide 加载网路图片：</description></item><item><title>Glide 高级用法</title><link>https://guanpj.github.io/amethyst/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid><description>回调与监听 # Target # 我们都知道，使用 Glide 在界面上加载并展示一张图片只需要一行代码：
Glide.with(this).load(url).into(imageView); 将 ImageView 的实例传入到 into() 方法当中，Glide 将图片加载完成之后，图片就能显示到 ImageView 上了。这是怎么实现的呢？来看一下 into() 方法的源码：
@NonNull public ViewTarget&amp;lt;ImageView, TranscodeType&amp;gt; into(@NonNull ImageView view) { Util.assertMainThread(); Preconditions.checkNotNull(view); BaseRequestOptions&amp;lt;?&amp;gt; requestOptions = this; if (!requestOptions.isTransformationSet() &amp;amp;&amp;amp; requestOptions.isTransformationAllowed() &amp;amp;&amp;amp; view.getScaleType() != null) { // Clone in this method so that if we use this RequestBuilder to load into a View and then // into a different target, we don&amp;#39;t retain the transformation applied based on the previous // View&amp;#39;s scale type.</description></item><item><title>HashMap 源码解析</title><link>https://guanpj.github.io/amethyst/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>前言 # HashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。
在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。
成员变量 # HashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：
public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;  implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable {  // 初始容量 16  static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16  // 最大容量，该数组最大值为2^31一次方。  static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;  // 默认的加载因子，如果构造的时候不传则为 0.</description></item><item><title>LeakCanary 使用及源码解析</title><link>https://guanpj.github.io/amethyst/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>Reference 介绍 # Reference 即是我们平时所说的“引用”，与之对应的是一个泛型抽象类。四种引用类型：SoftReference(软引用)、WeakReference(弱引用)、PhantomReference（虚引用）都继承自 Reference。它的声明如下：
public abstract class Reference&amp;lt;T&amp;gt; { //引用对象 volatile T referent; //保存即将被回收的Reference对象 final ReferenceQueue&amp;lt;? super T&amp;gt; queue; //在Enqueued状态下即引用加入队列时，指向下一个待处理Reference对象,默认为null Reference queueNext; //在Pending状态下，待入列引用，默认为null Reference&amp;lt;?&amp;gt; pendingNext; ... } Reference 有四种状态：Active、Pending、Enqueued、Inactive，默认为 Active 状态。
ReferenceQueue 则是一个单向链表实现的队列数据结构，存储的是 Reference 对象。包含了入列 enqueue、出列 poll 和移除 remove 操作。
ReferenceQueue 原理和使用示例 # Reference 配合 ReferenceQueue 可以实现对象回收监听，使用方法如下：
//创建一个引用队列 ReferenceQueue queue = new ReferenceQueue(); //创建对象 Object object = new Object(); //创建 object 对象的弱引用，并关联引用队列 queue WeakReference reference = new WeakReference(object, queue); System.</description></item><item><title>OkHttp 使用及源码分析</title><link>https://guanpj.github.io/amethyst/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>https://juejin.cn/post/6881436122950402056
请求流程 # 同步请求 # MainActivity.kt
val user = &amp;#34;guanpj&amp;#34; val client = OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .writeTimeout(30, TimeUnit.SECONDS) .readTimeout(30, TimeUnit.SECONDS) .proxy(Proxy.NO_PROXY) .addInterceptor(HttpLoggingInterceptor { message -&amp;gt; if (BuildConfig.DEBUG) { Log.i(&amp;#34;OkHttp&amp;#34;, message) } }) .build() val request: Request = Request.Builder() .url(&amp;#34;https://api.github.com/users/$user/repos&amp;#34;) .build() val response = client.newCall(request).execute() println(&amp;#34;Response status code: ${response.code}&amp;#34;) OkHttpClient.kt
/** Prepares the [request] to be executed at some point in the future.</description></item><item><title>Retrofit 使用及源码分析</title><link>https://guanpj.github.io/amethyst/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>使用 # 导入依赖。 implementation &amp;#34;com.squareup.okhttp3:okhttp:4.9.0&amp;#34; implementation &amp;#34;com.squareup.okhttp3:logging-interceptor:4.9.0&amp;#34; implementation &amp;#34;com.squareup.retrofit2:retrofit:2.9.0&amp;#34; implementation &amp;#34;com.squareup.retrofit2:converter-gson:2.9.0&amp;#34; implementation &amp;#34;com.squareup.retrofit2:adapter-rxjava3:2.9.0&amp;#34; implementation &amp;#34;io.reactivex.rxjava3:rxjava:3.0.0&amp;#34; implementation &amp;#34;io.reactivex.rxjava3:rxandroid:3.0.0&amp;#34; 创建一个 interface 作为 WebService 的请求集合，在里面用注解写入需要配置的请求方法。 interface GitHubService { @GET(&amp;#34;users/{user}/repos&amp;#34;) fun listRepos(@Path(&amp;#34;user&amp;#34;) user: String?): Call&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; @GET(&amp;#34;users/{user}/repos&amp;#34;) fun listReposRx(@Path(&amp;#34;user&amp;#34;) user: String?): Observable&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; @GET(&amp;#34;users/{user}/repos&amp;#34;) fun listReposCompletable(@Path(&amp;#34;user&amp;#34;) user: String?): CompletableFuture&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; @GET(&amp;#34;users/{user}/repos&amp;#34;) suspend fun listReposSuspend(@Path(&amp;#34;user&amp;#34;) user: String?): List&amp;lt;Repo&amp;gt; @GET(&amp;#34;users/{user}/repos&amp;#34;) fun listReposOptional(@Path(&amp;#34;user&amp;#34;) user: String?</description></item><item><title>RxJava 使用及源码分析</title><link>https://guanpj.github.io/amethyst/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guanpj.github.io/amethyst/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>https://juejin.cn/post/6881436122950402056
介绍 # Rx 是 ReactiveX 的简写，后者是 Reactive Extensions 的缩写，Rx 是一种编程模型，用于方便处理异步数据流。
RxJava 是响应式编程（Reactive Extensions）在 Java VM 上的实现，是一个在 Java VM 上使用可观察序列来组成异步的、基于事件的程序库。
它扩展了观察者模式以支持数据/事件序列，并添加了运算符，允许以声明方式将序列组合在一起，同时抽象出对低级线程、同步、线程安全和并发数据结构等事物的关注。
RxJava 是一个 基于事件流、实现异步操作的库，因此它具有如下特点：
异步。这里主要就是两个核心的方法 subscribeOn 和 observeOn。这两个方法都传入一个 Scheduler 对象，subscribeOn 指定产生事件的线程，observeOn 指定消费事件的线程。 强大的操作符。提供了一系列的转换操作符，可以将事件序列中的某个事件或整个事件序列进行加工处理，转换成不同的事件或事件序列，然后再发送出去。 简洁。由于采用链式调用的方式进行事件流的处理，RxJava 在应对较复杂的逻辑的时候，也能展现出清晰的思路。异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和 Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 观察者模式 # RxJava 有四个基本概念：Observable (可观察者，被观察者，生产者)、 Observer (观察者，消费者)、 subscribe (订阅)、Event (事件)。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，Observable 可以在需要的时候发出事件来通知 Observer，且 RxJava 支持事件以队列的形式连续发送。
角色 作用 被观察者（Observable） 产生事件 观察者（Observer） 接收事件，并给出响应动作 订阅（Subscribe） 连接 被观察者 &amp;amp; 观察者 事件（Event） 被观察者 &amp;amp; 观察者 沟通的载体 RxJava 的整体结构是一条链，其中：</description></item></channel></rss>